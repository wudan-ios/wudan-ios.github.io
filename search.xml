<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F09%2FiOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%9APopMenu%2F</url>
    <content type="text"><![CDATA[现在很多的应用都有类似的弹窗控件，最出名应该是企鹅和微信了吧。想着为了满足自己的效果就动手写了这个。首先要感谢写出弹窗箭头的代码的人iHandle，这方面的知识我很欠缺，以后找机会恶补一下。先上两张出名的效果图： 样式定义主要以UITableView作为容器显示样式 背景颜色 文字样式：颜色，字体大小，对齐方式 显示类型：仅文字，仅图标，文字 + 图标 是否显示下划线 箭头方向 弹窗宽度 单元格的高度 箭头生成123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152typedef NS_ENUM(NSInteger, ArrowDirection) &#123; ArrowDirectionRight = 0, ArrowDirectionBottom, ArrowDirectionLeft, ArrowDirectionTop,&#125;;#define CORNER_RADIUS 8 // 默认矩形框圆角半径#define ARROW_WIDTH 30 // 默认箭头宽带#define ARROW_HEIGHT 12 // 默认箭头高度#define ARROW_DIRECTION 1 // 默认箭头方向，向下#define ARROW_POSITION 0.5 // 默认箭头相对位置，居中#define ARROW_RADIUS 3 // 默认箭头指向处的圆角半径@interface WudanLayer : NSObject@property (nonatomic, assign) CGFloat cornerRadius;@property (nonatomic, assign) CGFloat arrowRadius;@property (nonatomic, assign) CGFloat arrowHeight;@property (nonatomic, assign) CGFloat arrowWidth;@property (nonatomic, assign) ArrowDirection arrowDirection;@property (nonatomic, assign) CGFloat arrowPosition;@property (nonatomic, assign) CGSize size;- (instancetype)initWithSize:(CGSize)size;- (CAShapeLayer *)layer;@end@implementation WudanLayer#pragma mark - preparation- (NSMutableArray *)keyPoints &#123; NSMutableArray *points = [NSMutableArray array]; CGPoint beginPoint; CGPoint topPoint; CGPoint endPoint; CGFloat validWidthForTopPoint = _size.width - 2 * _cornerRadius - _arrowWidth; CGFloat validHeightForTopPoint = _size.height - 2 * _cornerRadius - _arrowWidth; CGFloat x = 0, y = 0; CGFloat width = _size.width, height = _size.height; switch (_arrowDirection) &#123; case ArrowDirectionRight: &#123; width -= _arrowHeight; topPoint = CGPointMake(_size.width , _size.height / 2 + validHeightForTopPoint*(_arrowPosition - 0.5)); beginPoint = CGPointMake(topPoint.x - _arrowHeight, topPoint.y - _arrowWidth/2); endPoint = CGPointMake(beginPoint.x, beginPoint.y + _arrowWidth); &#125; break; case ArrowDirectionBottom: &#123; height -= _arrowHeight; topPoint = CGPointMake(_size.width / 2 + validWidthForTopPoint*(_arrowPosition - 0.5), _size.height); beginPoint = CGPointMake(topPoint.x + _arrowWidth/2, topPoint.y - _arrowHeight); endPoint = CGPointMake(beginPoint.x - _arrowWidth, beginPoint.y); &#125; break; case ArrowDirectionLeft: &#123; x = _arrowHeight; width -= _arrowHeight; topPoint = CGPointMake(0, _size.height / 2 + validHeightForTopPoint*(_arrowPosition - 0.5)); beginPoint = CGPointMake(topPoint.x + _arrowHeight, topPoint.y + _arrowWidth/2); endPoint = CGPointMake(beginPoint.x, beginPoint.y - _arrowWidth); &#125; break; case ArrowDirectionTop: &#123; y = _arrowHeight; height -= _arrowHeight; topPoint = CGPointMake(_size.width / 2 + validWidthForTopPoint*(_arrowPosition - 0.5), 0); beginPoint = CGPointMake(topPoint.x - _arrowWidth/2, topPoint.y + _arrowHeight); endPoint = CGPointMake(beginPoint.x + _arrowWidth, beginPoint.y); &#125; break; &#125; points = [NSMutableArray arrayWithObjects: [NSValue valueWithCGPoint:beginPoint], [NSValue valueWithCGPoint:topPoint], [NSValue valueWithCGPoint:endPoint], nil]; CGPoint bottomRight = CGPointMake(x + width, y + height); CGPoint bottomLeft = CGPointMake(x, y + height); CGPoint topLeft = CGPointMake(x, y); CGPoint topRight = CGPointMake(x + width, y); NSMutableArray *rectPoints = [NSMutableArray arrayWithObjects: [NSValue valueWithCGPoint:bottomRight], [NSValue valueWithCGPoint:bottomLeft], [NSValue valueWithCGPoint:topLeft], [NSValue valueWithCGPoint:topRight], nil]; int rectPointIndex = (int)_arrowDirection; for(int i = 0; i &lt; 4; ++i) &#123; [points addObject:[rectPoints objectAtIndex:rectPointIndex]]; rectPointIndex = (rectPointIndex + 1) % 4; &#125; return points;&#125;#pragma mark - Draw bubblePath- (CGPathRef)bubblePath &#123; UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0); CGContextRef ctx = UIGraphicsGetCurrentContext(); NSMutableArray *points = [self keyPoints]; CGPoint currentPoint = [[points objectAtIndex:6] CGPointValue]; CGContextMoveToPoint(ctx, currentPoint.x, currentPoint.y); CGPoint pointA, pointB; CGFloat radius; int i = 0; while(1) &#123; if (i &gt; 6) break; radius = i &lt; 3 ? _arrowRadius : _cornerRadius; pointA = [[points objectAtIndex:i] CGPointValue]; pointB = [[points objectAtIndex:(i + 1) % 7] CGPointValue]; CGContextAddArcToPoint(ctx, pointA.x, pointA.y, pointB.x, pointB.y, radius); i = i + 1; &#125; CGContextClosePath(ctx); CGPathRef path = CGContextCopyPath(ctx); CGContextRelease(ctx); return path;&#125;- (CAShapeLayer *)layer&#123; CAShapeLayer *layer = [CAShapeLayer layer]; layer.path = [self bubblePath]; return layer;&#125;#pragma mark - Setup- (void)setDefaultProperty &#123; _cornerRadius = CORNER_RADIUS; _arrowWidth = ARROW_WIDTH; _arrowHeight = ARROW_HEIGHT; _arrowDirection = ARROW_DIRECTION; _arrowPosition = ARROW_POSITION; _arrowRadius = ARROW_RADIUS;&#125;#pragma mark - Init- (instancetype)initWithSize:(CGSize)size &#123; if(self = [super init]) &#123; [self setDefaultProperty]; _size = size; &#125; return self;&#125;@end 单元格默认样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172typedef NS_ENUM(NSInteger, WDPopMenuType) &#123; WDPopMenuTypeNormal, WDPopMenuTypeOnlyTitle, WDPopMenuTypeOnlyIcon,&#125;;@interface WDPopMenuCell : UITableViewCell@property (nonatomic, strong) UIImageView *iconImageView;@property (nonatomic, strong) UILabel *titleLabel;@property (nonatomic, assign) WDPopMenuType showType;@end@implementation WDPopMenuCell- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123; self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if (self) &#123; [self setupSubViewsProperties]; &#125; return self;&#125;- (void)setupSubViewsProperties &#123; self.iconImageView = [[UIImageView alloc] init]; self.iconImageView.contentMode = UIViewContentModeScaleAspectFit; self.iconImageView.translatesAutoresizingMaskIntoConstraints = NO; [self.contentView addSubview:self.iconImageView]; self.titleLabel = [[UILabel alloc] init]; self.titleLabel.font = [UIFont systemFontOfSize:15]; self.titleLabel.textColor = [UIColor blackColor]; self.titleLabel.translatesAutoresizingMaskIntoConstraints = NO; [self.contentView addSubview:self.titleLabel];&#125;- (void)setShowType:(WDPopMenuType)showType &#123; _showType = showType; [self setupSubViewsConstraint];&#125;- (void)setTitleLabel:(UILabel *)titleLabel &#123; _titleLabel = titleLabel; titleLabel.translatesAutoresizingMaskIntoConstraints = NO;&#125;- (void)setupSubViewsConstraint &#123; if (self.showType == WDPopMenuTypeNormal) &#123; self.titleLabel.textAlignment = NSTextAlignmentLeft; [self.contentView addConstraints:@[ [NSLayoutConstraint constraintWithItem:self.iconImageView attribute:NSLayoutAttributeLeading relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeLeading multiplier:1 constant:15], [NSLayoutConstraint constraintWithItem:self.iconImageView attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterY multiplier:1 constant:0], ]]; [self.contentView addConstraints:@[ [NSLayoutConstraint constraintWithItem:self.titleLabel attribute:NSLayoutAttributeLeading relatedBy:NSLayoutRelationEqual toItem:self.iconImageView attribute:NSLayoutAttributeTrailing multiplier:1 constant:10], [NSLayoutConstraint constraintWithItem:self.titleLabel attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterY multiplier:1 constant:0], ]]; &#125; else if (self.showType == WDPopMenuTypeOnlyTitle)&#123; self.titleLabel.textAlignment = NSTextAlignmentCenter; [self.contentView addConstraints:@[ [NSLayoutConstraint constraintWithItem:self.titleLabel attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterX multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:self.titleLabel attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterY multiplier:1 constant:0], ]]; &#125; else &#123; [self.contentView addConstraints:@[ [NSLayoutConstraint constraintWithItem:self.iconImageView attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterX multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:self.iconImageView attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.contentView attribute:NSLayoutAttributeCenterY multiplier:1 constant:0], ]]; &#125;&#125;@end 接口代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@interface WDPopMenu : UIView@property (nonatomic, copy, readonly) NSArray&lt;NSString *&gt; *titles;@property (nonatomic, copy, readonly) NSArray&lt;NSString *&gt; *iconImageNames;/** 仅显示图标 + 默认样式 @param iconImageNames 图标数组 @param position 初始位置 @param complete 点击回调 */+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; *)iconImageNames originPosition:(CGPoint)position selectedItemComplete:(void(^)(NSInteger currentIndex))complete;/** 仅显示图标 + 默认样式 @param iconImageNames 图标数组 @param position 初始位置 @param isNeedSeparatorLine 是否显示分割线 @param complete 点击回调 */+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; *)iconImageNames originPosition:(CGPoint)position needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete;/** 仅显示标题 + 默认样式 @param titles 标题数组 @param position 初始位置 @param complete 点击回调 */+ (void)showPopMenuWithTitles:(NSArray&lt;NSString *&gt; *)titles originPosition:(CGPoint)position selectedItemComplete:(void(^)(NSInteger currentIndex))complete;/** 仅显示标题 + 默认样式 @param titles 标题数组 @param position 初始位置 @param isNeedSeparatorLine 是否显示分割线 @param complete 点击回调 */+ (void)showPopMenuWithTitles:(NSArray&lt;NSString *&gt; *)titles originPosition:(CGPoint)position needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete;/** 显示文字和图标 + 默认样式 @param iconImageNames 图标数组 @param titles 标题数组 @param position 初始位置 @param complete 点击回调 */+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position selectedItemComplete:(void(^)(NSInteger currentIndex))complete;/** 显示文字和图标 + 默认样式 @param iconImageNames 图标数组 @param titles 标题数组 @param position 初始位置 @param isNeedSeparatorLine 是否显示分割线 @param complete 点击回调 */+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete;/** 可选显示图标、标题 @param iconImageNames 图片数组 可以为空 @param titles 标题数组 可以为空 @param position 初始位置 @param height 单个item高度 默认为45 @param width 显示View的高度 默认为屏幕宽度的一半 @param color 显示View的背景颜色 @param isNeedSeparatorLine 是否显示分割线 @param complete 点击回调 */+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position heightOfItem:(CGFloat)height widthOfView:(CGFloat)width backgroundColorOfView:(UIColor *)color needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete;/** 可选显示图标、标题 @param iconImageNames 图片数组 可以为空 @param titles 标题数组 可以为空 @param position 初始位置 @param height 单个item高度 默认为45 @param width 显示View的高度 默认为屏幕宽度的一半 @param color 显示View的背景颜色 @param isNeedSeparatorLine 是否显示分割线 @param titleLabel 自定义Item的Label样式 @param complete 点击回调 */+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position heightOfItem:(CGFloat)height widthOfView:(CGFloat)width backgroundColorOfView:(UIColor *)color titleLabelOfItem:(UILabel * _Nullable)titleLabel needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete;@endNS_ASSUME_NONNULL_END 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310#define WD_SCREEN_WIDTH ([[UIScreen mainScreen] bounds].size.width)#define WD_SCREEN_HEIGHT ([[UIScreen mainScreen] bounds].size.height)@interface WDPopMenu () &lt;UITableViewDataSource, UITableViewDelegate&gt;@property (nonatomic, copy) void (^selectedItemComplete)(NSInteger currentIndex);@property (nonatomic, strong) UIView *backgroundView;@property (nonatomic, strong) UITableView *tableView;@property (nonatomic, strong) UILabel *titleLabel;@property (nonatomic, assign) CGFloat viewWidth;@property (nonatomic, assign) CGFloat itemHeight;@property (nonatomic, assign) CGPoint beginPosition;@property (nonatomic, strong) UIColor *cellColor;@property (nonatomic, copy, readwrite) NSArray&lt;NSString *&gt; *titles;@property (nonatomic, copy, readwrite) NSArray&lt;NSString *&gt; *iconImageNames;@end@implementation WDPopMenu- (instancetype)init &#123; self = [super init]; if (self) &#123; [self addSubview:self.tableView]; UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(backgroundTappedTarget:)]; [self.backgroundView addGestureRecognizer:tap]; &#125; return self;&#125;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; *)iconImageNames originPosition:(CGPoint)position selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; [self showPopMenuWithIconImageNames:iconImageNames originPosition:position needSeparatorLine:YES selectedItemComplete:complete];&#125;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; *)iconImageNames originPosition:(CGPoint)position needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; [self showPopMenuWithIconImageNames:iconImageNames titles:nil originPosition:position needSeparatorLine:isNeedSeparatorLine selectedItemComplete:complete];&#125;+ (void)showPopMenuWithTitles:(NSArray&lt;NSString *&gt; *)titles originPosition:(CGPoint)position selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; [self showPopMenuWithTitles:titles originPosition:position needSeparatorLine:YES selectedItemComplete:complete];&#125;+ (void)showPopMenuWithTitles:(NSArray&lt;NSString *&gt; *)titles originPosition:(CGPoint)position needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; [self showPopMenuWithIconImageNames:nil titles:titles originPosition:position needSeparatorLine:isNeedSeparatorLine selectedItemComplete:complete];&#125;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; [self showPopMenuWithIconImageNames:iconImageNames titles:titles originPosition:position needSeparatorLine:YES selectedItemComplete:complete];&#125;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; [self showPopMenuWithIconImageNames:iconImageNames titles:titles originPosition:position heightOfItem:0 widthOfView:0 backgroundColorOfView:[UIColor whiteColor] needSeparatorLine:isNeedSeparatorLine selectedItemComplete:complete];&#125;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position heightOfItem:(CGFloat)height widthOfView:(CGFloat)width backgroundColorOfView:(UIColor *)color needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; [self showPopMenuWithIconImageNames:iconImageNames titles:titles originPosition:position heightOfItem:height widthOfView:width backgroundColorOfView:color titleLabelOfItem:nil needSeparatorLine:isNeedSeparatorLine selectedItemComplete:complete];&#125;+ (void)showPopMenuWithIconImageNames:(NSArray&lt;NSString *&gt; * _Nullable)iconImageNames titles:(NSArray&lt;NSString *&gt; * _Nullable)titles originPosition:(CGPoint)position heightOfItem:(CGFloat)height widthOfView:(CGFloat)width backgroundColorOfView:(UIColor *)color titleLabelOfItem:(UILabel * _Nullable)titleLabel needSeparatorLine:(BOOL)isNeedSeparatorLine selectedItemComplete:(void(^)(NSInteger currentIndex))complete &#123; WDPopMenu *v = [[WDPopMenu alloc] init]; v.iconImageNames = iconImageNames; v.titles = titles; v.beginPosition = position; v.itemHeight = height == 0 ? 45 : height; v.viewWidth = width == 0 ? [[UIScreen mainScreen] bounds].size.width / 2 : width; v.tableView.backgroundColor = color; v.cellColor = color; v.titleLabel = titleLabel; v.selectedItemComplete = complete; v.tableView.rowHeight = v.itemHeight; if (isNeedSeparatorLine) &#123; v.tableView.separatorStyle = UITableViewCellSeparatorStyleSingleLine; &#125; else &#123; v.tableView.separatorStyle = UITableViewCellSeparatorStyleNone; &#125; [v.tableView reloadData]; [v showView];&#125;- (void)backgroundTappedTarget:(id)sender &#123; [self hidenView];&#125;- (void)showView &#123; [[[UIApplication sharedApplication] keyWindow] addSubview:self.backgroundView]; [[[UIApplication sharedApplication] keyWindow] addSubview:self]; [self setupViewAndArrowShape]; [self showAnimation];&#125;- (void)setupViewAndArrowShape &#123; CGRect toFrame = CGRectZero; toFrame.size.width = self.viewWidth; if (self.iconImageNames.count == 0 || self.iconImageNames == nil) &#123; toFrame.size.height = self.itemHeight * self.titles.count + 15; &#125; else if (self.titles == nil || self.titles.count == 0) &#123; toFrame.size.height = self.itemHeight * self.iconImageNames.count + 15; &#125; else &#123; toFrame.size.height = self.itemHeight * self.titles.count + 15; &#125; WudanLayer *bbLayer = [[WudanLayer alloc] initWithSize:toFrame.size]; if (self.beginPosition.x + self.viewWidth / 2 &gt; WD_SCREEN_WIDTH) &#123; toFrame.origin.x = WD_SCREEN_WIDTH - 10 - self.viewWidth; bbLayer.arrowDirection = ArrowDirectionTop; bbLayer.arrowPosition = (self.beginPosition.x - toFrame.origin.x + 15) / self.viewWidth; self.layer.anchorPoint = CGPointMake(bbLayer.arrowPosition, 0); &#125; else if (self.beginPosition.x - self.viewWidth / 2 &lt; 0)&#123; toFrame.origin.x = 10; bbLayer.arrowDirection = ArrowDirectionTop; bbLayer.arrowPosition = (self.beginPosition.x - toFrame.origin.x - 15) / self.viewWidth; self.layer.anchorPoint = CGPointMake(bbLayer.arrowPosition, 0); &#125; else &#123; toFrame.origin.x = self.beginPosition.x - self.viewWidth / 2; bbLayer.arrowDirection = ArrowDirectionTop; bbLayer.arrowPosition = (self.beginPosition.x - toFrame.origin.x) / self.viewWidth; self.layer.anchorPoint = CGPointMake(bbLayer.arrowPosition, 0); &#125; if (self.beginPosition.y + toFrame.size.height &gt; WD_SCREEN_HEIGHT) &#123; toFrame.origin.y = self.beginPosition.y - toFrame.size.height - 15; bbLayer.arrowDirection = ArrowDirectionBottom; self.layer.anchorPoint = CGPointMake(bbLayer.arrowPosition, 1); &#125; else &#123; toFrame.origin.y = self.beginPosition.y + 15; &#125; self.tableView.frame = CGRectZero; self.frame = CGRectMake(self.beginPosition.x, self.beginPosition.y, 0, 0); self.alpha = 0; self.frame = toFrame; if (self.beginPosition.y + toFrame.size.height &gt; WD_SCREEN_HEIGHT) &#123; self.tableView.contentInset = UIEdgeInsetsZero; &#125; else &#123; self.tableView.contentInset = UIEdgeInsetsMake(15, 0, 0, 0); &#125; self.tableView.frame = CGRectMake(0, 0, toFrame.size.width, toFrame.size.height); bbLayer.cornerRadius = 8; bbLayer.arrowHeight = 15; bbLayer.arrowWidth = 30; bbLayer.arrowRadius = 0; [self.layer setMask:[bbLayer layer]];&#125;- (void)showAnimation &#123; self.layer.affineTransform = CGAffineTransformMakeScale(0.1, 0.1); [UIView animateWithDuration:0.35 animations:^&#123; self.backgroundView.backgroundColor = [UIColor colorWithWhite:0 alpha:0.1]; self.alpha = 1; self.layer.affineTransform = CGAffineTransformIdentity; &#125;];&#125;- (void)hidenView &#123; [UIView animateWithDuration:0.35 animations:^&#123; self.alpha = 0; self.layer.affineTransform = CGAffineTransformMakeScale(0.1, 0.1); self.backgroundView.backgroundColor = [UIColor colorWithWhite:0 alpha:0]; &#125; completion:^(BOOL finished) &#123; [self removeFromSuperview]; self.layer.affineTransform = CGAffineTransformIdentity; [self.backgroundView removeFromSuperview]; &#125;];&#125;#pragma mark - UITableView DataSource Method- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; if (self.titles.count &gt; 0) &#123; return self.titles.count; &#125; if (self.iconImageNames.count &gt; 0)&#123; return self.iconImageNames.count; &#125; return 0;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; WDPopMenuCell *cell = [tableView dequeueReusableCellWithIdentifier:@"WDPopMenuCell"]; if (!cell) &#123; cell = [[WDPopMenuCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"WDPopMenuCell"]; &#125; if (self.iconImageNames.count == 0 || self.iconImageNames == nil) &#123; cell.showType = WDPopMenuTypeOnlyTitle; cell.titleLabel.text = self.titles[indexPath.row]; &#125; else if (self.titles == nil || self.titles.count == 0) &#123; cell.showType = WDPopMenuTypeOnlyIcon; cell.iconImageView.image = [UIImage imageNamed:self.iconImageNames[indexPath.row]]; &#125; else &#123; cell.showType = WDPopMenuTypeNormal; cell.iconImageView.image = [UIImage imageNamed:self.iconImageNames[indexPath.row]]; cell.titleLabel.text = self.titles[indexPath.row]; &#125; if (self.titleLabel) &#123; cell.titleLabel.textColor = self.titleLabel.textColor; cell.titleLabel.textAlignment = self.titleLabel.textAlignment; cell.titleLabel.font = self.titleLabel.font; &#125; cell.contentView.backgroundColor = self.cellColor; if (indexPath.row == [tableView numberOfRowsInSection:indexPath.section] - 1) &#123; cell.separatorInset = UIEdgeInsetsMake(0, self.bounds.size.width, 0, 0); &#125; else &#123; cell.separatorInset = UIEdgeInsetsMake(0, 0, 0, 0); &#125; return cell;&#125;#pragma mark - UITableView Delegate Method- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; [tableView deselectRowAtIndexPath:indexPath animated:YES]; [self hidenView]; self.selectedItemComplete(indexPath.row);&#125;#pragma mark - Setter- (UITableView *)tableView &#123; if (!_tableView) &#123; _tableView = [[UITableView alloc] initWithFrame:CGRectZero style:UITableViewStylePlain]; _tableView.tableFooterView = [[UIView alloc] init]; _tableView.dataSource = self; _tableView.delegate = self; _tableView.scrollEnabled = NO; &#125; return _tableView;&#125;- (UIView *)backgroundView &#123; if (!_backgroundView) &#123; _backgroundView = [[UIView alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; &#125; return _backgroundView;&#125;@end 实现效果图]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter-GridView(UICollectionView)]]></title>
    <url>%2F2019%2F04%2F26%2FFlutter-GridView(UICollectionView)%2F</url>
    <content type="text"><![CDATA[ListView列表视图，类似iOS中的UITableView，使用更加方便和个性化，里面children视图可以是任意的Widge。1234567891011121314151617181920212223242526272829303132333435363738void main() =&gt; runApp(WudanTableViewPage());class WudanTableViewPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Class Name', home: Scaffold( appBar: AppBar(title: Text('UITableView')), body: Center( child: ListView( scrollDirection: Axis.vertical, // 滚动方向 children: &lt;Widget&gt;[ new ListTile( title: Text("标题"), subtitle: Text("副标题"), leading: Icon(Icons.add_box),// 左边Widge trailing: Icon(Icons.airline_seat_flat), // 右边Widge isThreeLine: true, // 是否默认3行高度，subtitle不为空时才能使用 dense: false, // 设置为true后字体变小 selected: false, // 展示是否默认显示选中 ), new Image.network( "https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1554110093883&amp;di=9db9b92f1e6ee0396b574a093cc987d6&amp;imgtype=0&amp;src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn20%2F151%2Fw2048h1303%2F20180429%2F37c0-fzvpatr1915813.jpg", height: 60, fit: BoxFit.fitWidth, ), new Container( margin: EdgeInsets.all(10), color: Colors.orange, height: 100, ) ], ), ), ), ); &#125;&#125; 属性介绍 padding：内边距 scrollDirection：滚动方向]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter-ListView(UITableView)]]></title>
    <url>%2F2019%2F04%2F26%2FFlutter-ListView(UITableView)%2F</url>
    <content type="text"><![CDATA[ListView列表视图，类似iOS中的UITableView，使用更加方便和个性化，里面children视图可以是任意的Widge。1234567891011121314151617181920212223242526272829303132333435363738void main() =&gt; runApp(WudanTableViewPage());class WudanTableViewPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Class Name', home: Scaffold( appBar: AppBar(title: Text('UITableView')), body: Center( child: ListView( scrollDirection: Axis.vertical, // 滚动方向 children: &lt;Widget&gt;[ new ListTile( title: Text("标题"), subtitle: Text("副标题"), leading: Icon(Icons.add_box),// 左边Widge trailing: Icon(Icons.airline_seat_flat), // 右边Widge isThreeLine: true, // 是否默认3行高度，subtitle不为空时才能使用 dense: false, // 设置为true后字体变小 selected: false, // 展示是否默认显示选中 ), new Image.network( "https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1554110093883&amp;di=9db9b92f1e6ee0396b574a093cc987d6&amp;imgtype=0&amp;src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn20%2F151%2Fw2048h1303%2F20180429%2F37c0-fzvpatr1915813.jpg", height: 60, fit: BoxFit.fitWidth, ), new Container( margin: EdgeInsets.all(10), color: Colors.orange, height: 100, ) ], ), ), ), ); &#125;&#125; 属性介绍 padding：内边距 scrollDirection：滚动方向]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter-Image(UIImageView)]]></title>
    <url>%2F2019%2F04%2F26%2FFlutter-Image(UIImageView)%2F</url>
    <content type="text"><![CDATA[Image就是相对于iOS开发中的UIImageView，把与UIImageView设置差别很大的点拎出来说明一下。123456789101112131415161718void main() =&gt; runApp(WudanImageViewPage());class WudanImageViewPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Class Name', home: Scaffold( appBar: AppBar(title: Text('UIImageView')), body: Center( child: Image.network( "https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1554110093883&amp;di=9db9b92f1e6ee0396b574a093cc987d6&amp;imgtype=0&amp;src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn20%2F151%2Fw2048h1303%2F20180429%2F37c0-fzvpatr1915813.jpg", fit: BoxFit.cover, ), ), ), ); &#125;&#125; 加载方式 Image.asset：加载资源图片，就是加载项目资源目录中的图片,加入图片后会增大打包的包体体积，用的是相对路径。 Image.network：网络资源图片 Image.file：加载本地图片，就是加载本地文件中的图片，这个是一个绝对路径，跟包体无关。 Image.memory：加载Uint8List资源图片fit属性的设置 BoxFit.fill:全图显示，图片会被拉伸，并充满父容器。 BoxFit.contain:全图显示，显示原比例，可能会有空隙。BoxFit.cover：显示可能拉伸，可能裁切，充满（图片要充满整个容器，还不变形）。 BoxFit.fitWidth：宽度充满（横向充满），显示可能拉伸，可能裁切。 BoxFit.fitHeight ：高度充满（竖向充满）,显示可能拉伸，可能裁切。 BoxFit.scaleDown：效果和contain差不多，但是此属性不允许显示超过源图片大小，可小不可大。图片的混合模式图片混合模式（colorBlendMode）和color属性配合使用，能让图片改变颜色，里边的模式非常的多，产生的效果也是非常丰富的。12345child: Image.network( 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1554110093883&amp;di=9db9b92f1e6ee0396b574a093cc987d6&amp;imgtype=0&amp;src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn20%2F151%2Fw2048h1303%2F20180429%2F37c0-fzvpatr1915813.jpg', color: Colors.greenAccent, colorBlendMode: BlendMode.darken,),]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter-Container(UIView)]]></title>
    <url>%2F2019%2F04%2F26%2FFlutter-Container(UIView)%2F</url>
    <content type="text"><![CDATA[Container就是相对于iOS开发中的UIView，把与UIView设置差别很大的点拎出来说明一下。1234567891011121314151617181920212223void main() =&gt; runApp(WudanViewPage());class WudanViewPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Class Name', home: Scaffold( appBar: AppBar(title: Text('UIView')), body: Center( child: Container( height: 300, color: Colors.red, padding: EdgeInsets.fromLTRB(10, 30, 30, 10), // 内边距 margin: EdgeInsets.fromLTRB(5, 5, 5, 5), // 外边距 child: Container( color: Colors.orange, ), ), ), ), ); &#125;&#125; 添加子视图使用child，在其内部设置子视图样式 盒子模型 fromLTRB 是(Left, Top, Right, Bottom) padding内边距 margin外边距]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter-Text(UILabel)]]></title>
    <url>%2F2019%2F04%2F26%2FFlutter-Text(UILabel)%2F</url>
    <content type="text"><![CDATA[Text就是相对于iOS开发中的UILabel，把与UILabel设置差别很大的点拎出来说明一下。1234567891011121314151617181920212223242526void main() =&gt; runApp(WudanUILabel());class WudanUILabel extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Class Name', home: Scaffold( appBar: AppBar(title: Text('UILabel')), body: Center( child: Text( "Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。", // 内容 maxLines: 2, // 最大显示行数，默认为最大 textAlign: TextAlign.left, // 对齐方式 overflow: TextOverflow.ellipsis, // 文字显示不全样式 style: TextStyle( // 字体样式 color: Colors.pink, // 颜色 fontSize: 18, // 大小 decoration: TextDecoration.underline, // 划线位置 decorationStyle: TextDecorationStyle.solid // 划线样式 ), ), ), ), ); &#125;&#125; overflow属性类似与UILabel中的lineBreakMode clip：直接切断，剩下的文字就没有了，感觉不太友好，体验性不好。 ellipsis: 在后边显示省略号，体验性较好，这个在工作中经常使用。 fade: 溢出的部分会进行一个渐变消失的效果，当然是上线的渐变。decoration类似于NSAttributedString制作的划线 none：默认样式，什么都没有 underline：下划线 lineThrough：穿过文字中间 overline：文字顶部 decorationStyle划线的样式 solid：实线 double：双线 dashed：虚线(大点) dotted：虚线(小点) wavy：波浪线]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS自定义控件：图片浏览器]]></title>
    <url>%2F2019%2F04%2F19%2FiOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%9A%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一直想写一个自己的图片浏览器，但是自己能力又不是很够，所以一直拖这，最近趁自己时间充裕，自己研究了一下这方面的知识。感觉有以下几个难点： 显示和消失的转场动画 手势拖拽 图片加载 加载方式和转场动画 通过Controller加载：需要使用ViewController实现UIViewControllerAnimatedTransitioning实现转场效果 通过View加载：使用UIView动画试下转场效果 转场动画必要元素 显示时需要fromView的frame 消失时需要toView的frame显示通过修改当前需要显示图片的CollectionViewCell中ImageView的frame，同时修改当期View的背景颜色透明度1234567WDImageCollectionViewCell *cell = (WDImageCollectionViewCell *)[self.collectionView cellForItemAtIndexPath:[NSIndexPath indexPathForRow:self.tappedIndex inSection:0]];CGRect fromFrame = [self.originView convertRect:self.originView.bounds toView:cell.contentView];cell.imageView.frame = fromFrame;[UIView animateWithDuration:0.5 animations:^&#123; self.backgroundColor = [[UIColor alloc] initWithWhite:0 alpha:1]; cell.imageView.frame = cell.contentView.bounds;&#125;]; 消失原理与显示相同12345678CGRect toRect = [self.originView convertRect:self.originView.bounds toView:self.window];[UIView animateWithDuration:0.5 animations:^&#123; cell.imageView.clipsToBounds = YES; cell.imageView.frame = toRect; self.backgroundColor = [[UIColor alloc] initWithWhite:0 alpha:0];&#125; completion:^(BOOL finished) &#123; [self removeFromSuperview];&#125;]; 拖拽的手势将手势添加在CollectionViewCell中ScrollView上，并遵循UIGestureRecognizerDelegate协议，不然会CollectionView无法进行滚动操作。 声明一个全局属性 1CGPoint firstTouchPoint; 实现代理 12345678910111213141516171819#pragma mark - UIGestureRecognizer Delegate Method- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch &#123; firstTouchPoint = [touch locationInView:self.window]; return YES;&#125;- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123; CGPoint touchPoint = [gestureRecognizer locationInView:self.window]; CGFloat dirTop = firstTouchPoint.y - touchPoint.y; if (dirTop &gt; -10 &amp;&amp; dirTop &lt; 10) &#123; return NO; &#125; CGFloat dirLift = firstTouchPoint.x - touchPoint.x; if (dirLift &gt; -10 &amp;&amp; dirLift &lt; 10 &amp;&amp; self.scrollView.frame.size.height &gt; [[UIScreen mainScreen] bounds].size.height) &#123; return NO; &#125; return YES;&#125;``` 拖动手势操作，同意代理传给View 协议方法 1234567```@class WDImageCollectionViewCell;@protocol WDImageCollectionViewCellDelegate &lt;NSObject&gt;- (void)collectionViewCell:(WDImageCollectionViewCell *)cell singleTapActionWithImageUrl:(NSString *)imageUrl;- (void)collectionViewCell:(WDImageCollectionViewCell *)cell panActionWithPercent:(CGFloat)percent;- (void)collectionViewCell:(WDImageCollectionViewCell *)cell dimssViewWithImageUrl:(NSString *)imageUrl;@end 拖动手势方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#pragma mark - UIGestureRecognizer Target Event/** 滑动手势 */- (void)didRecognizedPanGuesture:(UIPanGestureRecognizer *)pan &#123; CGPoint point = [pan translationInView:self.window]; CGFloat scale = 1.0 - ABS(point.y) / [[UIScreen mainScreen] bounds].size.height; switch (pan.state) &#123; case UIGestureRecognizerStateBegan: &#123;&#125; break; case UIGestureRecognizerStateChanged: &#123; scale = MAX(scale, 0); CGFloat s = MAX(scale, 0.5); CGAffineTransform translation = CGAffineTransformMakeTranslation(point.x / s, point.y / s); CGAffineTransform translationScale = CGAffineTransformMakeScale(s, s); self.imageView.transform = CGAffineTransformConcat(translation, translationScale); // 传出translationScale，修改背景颜色透明度 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(collectionViewCell:panActionWithPercent:)]) &#123; [self.delegate collectionViewCell:self panActionWithPercent:scale]; &#125; &#125; break; case UIGestureRecognizerStateCancelled | UIGestureRecognizerStateFailed: &#123; self.imageView.transform = CGAffineTransformIdentity; // 回复初始样式，传出translationScale，修改背景颜色透明度 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(collectionViewCell:panActionWithPercent:)]) &#123; [self.delegate collectionViewCell:self panActionWithPercent:1]; &#125; &#125; break; case UIGestureRecognizerStateEnded: &#123; [UIView animateWithDuration:0.5 animations:^&#123; CGAffineTransform transform1 = CGAffineTransformMakeTranslation(0,0); self.imageView.transform = CGAffineTransformScale(transform1, 1, 1); &#125;]; // 回复初始样式，传出translationScale，修改背景颜色透明度 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(collectionViewCell:panActionWithPercent:)]) &#123; [self.delegate collectionViewCell:self panActionWithPercent:scale]; &#125; if (scale &lt; 0.7) &#123; // 拖动结束，让页面消失 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(collectionViewCell:dimssViewWithImageUrl:)]) &#123; [self.delegate collectionViewCell:self dimssViewWithImageUrl:self.imageUrl]; &#125; &#125; else &#123; // 回复初始样式，传出translationScale，修改背景颜色透明度 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(collectionViewCell:panActionWithPercent:)]) &#123; [self.delegate collectionViewCell:self panActionWithPercent:1]; &#125; &#125; &#125; break; default: break; &#125;&#125; 图片加载使用SDWebImage获取图片，通过FLAnimatedImageView加载gif图 Github地址项目地址 效果图]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript与原生交互]]></title>
    <url>%2F2019%2F03%2F29%2FJavaScript%E4%B8%8E%E5%8E%9F%E7%94%9F%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[原生页面与HTML页面进行相互调用方式 | 适用对象—|—拦截URL | UIWebView和WKWebViewJavaScriptCore | UIWebViewMessageHandler | WKWebViewWebViewJavascriptBridge| UIWebView和WKWebView 实例HTML代码1234567891011121314151617181920212223242526272829303132333435&lt;body&gt; &lt;h2&gt;按钮点击&lt;/h2&gt; &lt;button type="submit" onclick="buttonEvent()" id="submitButto"&gt;提交&lt;/button&gt; &lt;h2&gt;文件上传&lt;/h2&gt; &lt;input type="file" /&gt; &lt;h2&gt;原生注入数据&lt;/h2&gt; &lt;input type="text" id="textField"&gt; &lt;input type="button" onclick="getTextEvent()" value="开始注入"&gt; &lt;script&gt; function loadURL(url) &#123; var iFrame; iFrame = document.createElement("iframe"); iFrame.setAttribute("src", url); iFrame.setAttribute("style", "display:none;"); iFrame.setAttribute("height", "0px"); iFrame.setAttribute("width", "0px"); iFrame.setAttribute("frameborder", "0"); document.body.appendChild(iFrame); iFrame.parentNode.removeChild(iFrame); iFrame = null; &#125; function buttonEvent()&#123; loadURL("/buttonEvent"); buttonDidPapped(); &#125; function getTextEvent() &#123; loadURL("/getText"); getTextButtonDidPapped(); &#125; function getText(text)&#123; document.getElementById("textField").value = text; &#125; &lt;/script&gt;&lt;/body&gt; 拦截URLUIWebView遵循UIWebViewDelegate调用- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType方法，判断获取的Url地址123456789101112131415// 调用JSif ([request.URL.absoluteString hasSuffix:@"buttonEvent"]) &#123; UIAlertController *vc = [UIAlertControlleralertControllerWithTitle:@"温馨提示" message:@"点击了提交按钮" preferredStyle:UIAlertControllerStyleAlert]; [vc addAction:[UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; [self presentViewController:vc animated:true completion:nil]; return NO;&#125; // 注入数据给JSif ([request.URL.absoluteString hasSuffix:@"getText"]) &#123; [webView stringByEvaluatingJavaScriptFromString:@"getText('哈哈')"]; return NO;&#125;return YES; WKWebView遵循WKNavigationDelegate调用- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler方法判断获取的地址1234567891011121314151617NSString *strRequest = [navigationAction.request.URL.absoluteString stringByRemovingPercentEncoding];// 调用JSif ([strRequest hasSuffix:@"buttonEvent"]) &#123; UIAlertController *vc = [UIAlertController alertControllerWithTitle:@"温馨提示" message:@"点击了提交按钮" preferredStyle:UIAlertControllerStyleAlert]; [vc addAction:[UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; [self presentViewController:vc animated:true completion:nil]; decisionHandler(WKNavigationActionPolicyCancel);&#125; else if ([strRequest hasSuffix:@"getText"]) &#123; // 注入数据给JS [webView evaluateJavaScript:@"getText('哈哈')" completionHandler:^(id _Nullable info, NSError * _Nullable error) &#123; NSLog(@"Error--%@, info--%@", error, info); &#125;]; decisionHandler(WKNavigationActionPolicyCancel);&#125; else &#123; decisionHandler(WKNavigationActionPolicyAllow);&#125; JavaScriptCore 导入&lt;JavaScriptCore/JavaScriptCore.h&gt; 遵循&lt;UIWebViewDelegate&gt;并实现- (void)webViewDidFinishLoad:(UIWebView *)webView方法。 12345678910111213141516171819202122// 对JSContext对象进行初始化JSContext *context = [self.webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];// 验证JSContext对象是否初始化成功context.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue)&#123; context.exception = exceptionValue;&#125;; // 调用JS context[@"buttonDidPapped"] = ^&#123; UIAlertController *vc = [UIAlertController alertControllerWithTitle:@"温馨提示" message:@"点击了提交按钮" preferredStyle:UIAlertControllerStyleAlert]; [vc addAction:[UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; [self presentViewController:vc animated:true completion:nil];&#125;; // 注入数据给JS context[@"getTextButtonDidPapped"] = ^&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.webView stringByEvaluatingJavaScriptFromString:@"getText('哈哈')"]; &#125;);&#125;; MessageHandler 修改js中的方法， 通过window.webkit.messageHandlers+操作方法 1234567function buttonEvent()&#123; window.webkit.messageHandlers.buttonEvent.postMessage(null);&#125; function getTextEvent() &#123; window.webkit.messageHandlers.getTextEvent.postMessage(null);&#125; 遵循WKScriptMessageHandler 在- (void)viewWillAppear:(BOOL)animated中添加scriptMessageHandler 在- (void)viewWillDisappear:(BOOL)animated中移除scriptMessageHandler 实现WKScriptMessageHandler方法 1234567891011121314151617181920212223242526272829303132- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [self.webView.configuration.userContentController addScriptMessageHandler:self name:@"buttonEvent"]; [self.webView.configuration.userContentController addScriptMessageHandler:self name:@"getTextEvent"];&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@"buttonEvent"]; [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@"getTextEvent"];&#125;#pragma mark - WKScriptMessageHandler Method- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123; // 调用JS if ([message.name isEqualToString:@"buttonEvent"]) &#123; UIAlertController *vc = [UIAlertController alertControllerWithTitle:@"温馨提示" message:@"点击了提交按钮" preferredStyle:UIAlertControllerStyleAlert]; [vc addAction:[UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; [self presentViewController:vc animated:true completion:nil]; return; &#125; // 注入数据给JS if ([message.name isEqualToString:@"getTextEvent"]) &#123; [self.webView evaluateJavaScript:@"getText('哈哈')" completionHandler:^(id _Nullable info, NSError * _Nullable error) &#123; NSLog(@"Error--%@, info--%@", error, info); &#125;]; return; &#125;&#125; WebViewJavascriptBridgeHTML代码123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;h2&gt;按钮点击&lt;/h2&gt; &lt;input id = 'submitBtn' type="button" value="提交按钮" onclick="submitClick()"/&gt; &lt;h2&gt;文件选择&lt;/h2&gt; &lt;input type="file" id="image"&gt; &lt;h2&gt;注入数据&lt;/h2&gt; &lt;input type="text" id="getTextField" /&gt; &lt;input type="button" value="开始获取" id = 'startGet' onclick="getTextClick()"/&gt; &lt;script&gt; function setupWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement('iframe'); WVJBIframe.style.display = 'none'; WVJBIframe.src = 'https://__bridge_loaded__'; document.documentElement.appendChild(WVJBIframe); setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0) &#125; setupWebViewJavascriptBridge(function(bridge) &#123; &#125;) function submitClick() &#123; WebViewJavascriptBridge.callHandler('submitClick', null, function(response) &#123; &#125;); &#125; function getTextClick() &#123; WebViewJavascriptBridge.callHandler('getTextClick', null, function(response) &#123; document.getElementById("getTextField").value = response; &#125;); &#125; &lt;/script&gt;&lt;/body&gt; 第三方库：地址 添加WebViewJavascriptBridge库 导入头文件#import &lt;WebViewJavascriptBridge.h&gt; 声明方法@property WebViewJavascriptBridge* bridge; 与WebView关联 123_bridge = [WebViewJavascriptBridge bridgeForWebView:self.webView];[_bridge setWebViewDelegate:self]; 调用js 1234567[_bridge registerHandler:@"submitClick" handler:^(id data, WVJBResponseCallback responseCallback) &#123; UIAlertController *vc = [UIAlertController alertControllerWithTitle:@"温馨提示" message:@"点击了提交按钮" preferredStyle:UIAlertControllerStyleAlert]; [vc addAction:[UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; [self presentViewController:vc animated:true completion:nil];&#125;]; 注入数据 123[_bridge registerHandler:@"getTextClick" handler:^(id data, WVJBResponseCallback responseCallback) &#123; responseCallback(@"哈哈哈");&#125;];]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS 单元测试]]></title>
    <url>%2F2019%2F03%2F27%2FiOS%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[单元测试以测试ViewController为例。 ViewController.h文件1234567891011#import &lt;UIKit/UIKit.h&gt;@interface ViewController : UIViewController/** 逻辑测试 */- (int)getSumWithNum1:(int)a num2:(int)b;/** 异步测试 */- (void)loadDataComplete:(void(^)(id info))complete;/** 性能测试 */- (void)openCamera;@end ViewController.m文件1234567891011121314151617181920212223- (int)getSumWithNum1:(int)a num2:(int)b &#123; return a + b;&#125;- (void)loadDataComplete:(void (^)(id))complete &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(2); NSString *data = @"😝"; dispatch_async(dispatch_get_main_queue(), ^&#123; complete(data); &#125;); &#125;);&#125;- (void)openCamera &#123; for(int i = 0; i &lt; 1000; ++i) &#123; NSLog(@"这是一个字符串%d", i); &#125;&#125;- (void)viewDidLoad &#123; [super viewDidLoad];&#125; 为了进行单元化测试，所以新建一个ViewControllerTest文件。步骤 导入测试头文件#import &quot;ViewController.h&quot; 声明属性@property (nonatomic, strong) ViewController *vc; 在- (void)setUp;进行初始化代码 123- (void)setUp &#123; self.vc = [[ViewController alloc] init];&#125; 1、逻辑测试 给出测试数据 进行测试 使用断言进行判定 123456789- (void)testSum &#123;// 1. givenint a = 10;int b = 22;// 2. whenint sum = [self.vc getSumWithNum1:a num2:b];// 3. thenXCTAssertEqual(sum, 32, @"错误");&#125; 2、异步测试 创建XCTestExpectation，设置错误提示 调用方法，在异步中调用fulfill 进行判断时间，是否在预期时间内容 12345678XCTestExpectation *exp = [self expectationWithDescription:@"超过预期时间"];[self.vc loadDataComplete:^(id info) &#123; XCTAssertNil(info, @"数据为空"); [exp fulfill];&#125;];[self waitForExpectationsWithTimeout:4 handler:^(NSError * _Nullable error) &#123; NSLog(@"%@", error);&#125;]; 3、性能测试 设置Baseline时间 Max STDDEV 最大样本标准偏差比例 12345- (void)testPerformanceExample &#123; [self measureBlock:^&#123; [self.vc openCamera]; &#125;];&#125; UI测试1、录制脚本2、编辑脚本3、自动化测试 获取代码覆盖率1、点击Edit Secheme2、选择Test-&gt;Options-&gt;Code Coverage勾起3、运行代码查看结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[属性修饰词]]></title>
    <url>%2F2019%2F03%2F27%2F%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[@property默认格式：@syntheszie var = _var; ARC中，默认修饰 基本数据类型@property (atomic, assign) 对象数据类型@property (atomic, strong) 修饰词解释 nonatomic 非原子性访问，不对set方法加锁，不是安全线程，但是性能高。 atomic 原子性访问，对生成的 set 方法加互斥锁 @synchronized(锁对象），安全线程（不是绝对安全线程）,性能差。 strongARC中使用，修饰OC对象，拥有关系，引用计数器+1。 reatainMRC中使用，修饰OC对象，拥有关系，引用计数器+1。 assign修饰基础数据类型，直接赋值，非拥有关系，不使用引用计数器。 weak修饰协议，控件，非拥有关系，指向的对象销毁，指针会自动置为nil，不使用引用计数器。 unsafe_unretained与weak类似，不会自动nil化，如果所指向的内存区域被释放了，这个指针就是一个野指针。 copy在 MRC 时是这样做的 release 旧对象( 旧对象的引用计数器 -1 ) , copy 新对象( 新对象的引用计数器 +1 ) , 然后指向新对象 .（新对象是指最终指向的那个对象，不管深拷贝还是浅拷贝），在 ARC 时是这么干的 copy 新对象( 新对象的引用计数器 +1 ) , 然后指向新对象。 readonly只生成get方法，不想把暴露的属性被人随便替换时 , 可以使用。 readwrite生成get/set方法。 @dynamic告诉编译器:属性的 setter 与 getter 方法由用户自己实现,不自动生成。(当然对于 readonly 的属性只需提供 getter 即可) @synthesize如果你没有手动实现 setter 方法和 getter 方法,那么编译器会自动为你加上这两个方法。 @synchronized线程同步锁 问题：（1）什么情况使用 weak 关键字？相比 assign 有什么不同? 使用 协议声明使用weak IBOutlet 使用weak weak 和 assign 的不同点: weak 策略在属性所指的对象遭到摧毁时,系统会将 weak 修饰的属性对象的指针指向 nil,在 OC 给 nil 发消息是不会有什么问题的;如果使用 assign 策略在属性所指的对象遭到摧毁时,属性对象指针还指向原来的对象,由于对象已经被销毁,这时候就产生了野指针,如果这时候在给此对象发送消息,很容造成程序奔溃assigin 可以用于修饰非 OC 对象,而 weak 必须用于 OC 对象。 （2）使用 atomic 一定是线程安全的吗? 不是,atomic 的本意是指属性的存取方法是线程安全的,并不保证整个对象是线程安全的。 例如： 声明一个 NSMutableArray 的原子属性 stuff,此时 self.stuff 和 self.stuff =othersulf 都是线程安全的。但是,使用[self.stuff objectAtIndex:index]就不是线程安全的,需要用互斥锁来保证线程安全性。 （3）@synthesize 和 @dynamic 分别有什么作用 @property 有两个对应的词,一个是@synthesize,一个是@dynamic。如果@synthesize 和@dynamic 都没写,那么默认的就是@syntheszie var = _var; @synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法,那么编译器会自动为你加上这两个方法。 @dynamic 告诉编译器:属性的 setter 与 getter 方法由用户自己实现,不自动生成。(当然对于 readonly 的属性只需提供 getter 即可) 假如一个属性被声明为@dynamic var；然后你没有提供@setter 方法和@getter 方法,编译的时候没问题,但是当程序运行到 instance.var = someVar,由于缺 setter方法会导致程序崩溃;或者当运行到 someVar = instance.var 时,由于缺 getter 方法同样会导致崩溃。 （4）ARC 下,不显式指定任何属性关键字时,默认的关键字都有哪些? 基本数据： atomic,readwrite,assign 普通的 OC 对象: atomic,readwrite,strong （5）用@property 声明的 NSString(或 NSArray,NSDictionary)经常使用 copy 关键字,为什么?如果改用 strong 关键字,可能造成什么问题? 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本. 如果我们使用是 strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性. （6）这个写法会出什么问题: @property(copy)NSMutableArray *array; 因为 copy 策略拷贝出来的是一个不可变对象,然而却把它当成可变对象使用,很容易造成程序奔溃这里还有一个问题,该属性使用了同步锁,会在创建时生成一些额外的代码用于帮助编写多线程程序,这会带来性能问题,通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销,在 iOS 开发中应该使用 nonatomic 替代 atomic. （7）如何让自定义类可以用 copy 修饰符?如何重写带 copy 关键字的 setter? 若想令自己所写的对象具有拷贝功能,则需实现 NSCopying 协议。1234567// 实现不可变版本拷贝- (id)copyWithZone:(NSZone *)zone; // 实现可变版本拷贝- (id)mutableCopyWithZone:(NSZone *)zone;// 重写带 copy 关键字的 setter- (void)setName:(NSString *)name &#123; _name = [name copy];&#125; 深拷贝和浅拷贝copy 和 mutableCopy copy拷贝出来的对象类型总是不可变类型(例如, NSString, NSDictionary, NSArray等等) mutableCopy拷贝出来的对象类型总是可变类型(例如, NSMutableString, NSMutableDictionary, NSMutableArray等等) copy 对于可变对象为深拷贝，对于不可变对象为浅拷贝 mutableCopy 始终是深拷贝]]></content>
  </entry>
  <entry>
    <title><![CDATA[Block]]></title>
    <url>%2F2019%2F03%2F26%2FBlock%2F</url>
    <content type="text"><![CDATA[Block的实质本质上也是一个OC对象，他内部也有一个isa指针。Block是封装了函数调用以及函数调用环境的OC对象。 Block三种类型 类型 存储区域 GlobalBlock 数据区 StackBlock 栈区 MallocBlock 堆区 Block避免循环引用的三种方式1、利用 __weak和__strong123456 __weak typeof(self) weakSelf = self;self.block = ^&#123; __strong typeof(self) strongSelf = weakSelf; NSLog(@"%@", NSStringFromCGRect(strongSelf.view.frame));&#125;;self.block(); 2、利用造成循环引用的临时变量123456__block ViewController *vc = self;self.block = ^&#123; NSLog(@"%@", NSStringFromCGRect(vc.view.frame)); vc = nil;&#125;;self.block(); 3、直接声明Block中添加造成循环引用的参数123456typedef void(^Block)(UIViewController *vc);self.block = ^(UIViewController *vc)&#123; NSLog(@"%@", NSStringFromCGRect(vc.view.frame));&#125;;self.block(self);]]></content>
  </entry>
  <entry>
    <title><![CDATA[KVO]]></title>
    <url>%2F2019%2F03%2F26%2FKVO%2F</url>
    <content type="text"><![CDATA[类的单个属性观察观察值的4中模式123456/** * NSKeyValueObservingOptionNew 新值 * NSKeyValueObservingOptionOld 旧值 * NSKeyValueObservingOptionInitial 注册发送通知，改变时发送通知 * NSKeyValueObservingOptionPrior 改变之前发送通知，改变后发送通知 */ 针对Person类里面的name属性进行观察1[person addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew context:nil]; 查看观察123- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; NSLog(@"%@", change);&#125; 打印效果12342019-03-22 09:20:16.875033+0800 KVO[1844:81256] &#123; kind = 1; new = 0;&#125; 类的里面嵌套其他的属性观察观察Person里面Dog类的age，通过点语法直接监听1[person addObserver:self forKeyPath:@"dog.age" options:NSKeyValueObservingOptionNew context:nil]; 输入结果12342019-03-22 09:23:25.854859+0800 KVO[1876:84141] &#123; kind = 1; new = 11;&#125; 一次性观察多个值例如观察Person里面的Dog的age和level，则在Person类中重新+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key12345678+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123; NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key]; if ([key isEqualToString:@"dog"]) &#123; NSArray *array = @[@"_dog.name", @"_dog.level"]; keyPaths = [keyPaths setByAddingObjectsFromArray:array]; &#125; return keyPaths;&#125; 直接观察Dog类1[person addObserver:self forKeyPath:@"dog" options:NSKeyValueObservingOptionNew context:nil]; 打印结果12342019-03-22 09:27:11.485240+0800 KVO[1929:87568] &#123; kind = 1; new = "&lt;Dog: 0x6000027c0b80&gt;";&#125; 手动模式在Person类中重写+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key1234+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123; // 修改为手动模式 return NO;&#125; 手动触发12[self.person willChangeValueForKey:@"name"];[self.person didChangeValueForKey:@"name"]; 观察容器类需要利用KVC例如观察person中的array1[[self.person mutableArrayValueForKey:@"array"] addObject:@"obj"]; 输出结果12345672019-03-22 11:02:13.996095+0800 KVO[5521:170395] &#123; indexes = "&lt;_NSCachedIndexSet: 0x600002216160&gt;[number of indexes: 1 (in 1 ranges), indexes: (0)]"; kind = 2; new = ( obj );&#125; KVO的底层实现实质：观察值的setter方法通过runtime，新建一个子类继承于观察类（NSKVONotifing_类名），动态的修改了观察类的类型为子类的类型,在子类里面重写set方法，调用12345- (void)setName:(NSString *)name &#123; [self willChangeValueForKey:@"name"]; [super setName:name]; [self didChangeValueForKey:@"name"]; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS-3D Touch]]></title>
    <url>%2F2019%2F03%2F21%2FiOS-3D%20Touch%2F</url>
    <content type="text"><![CDATA[桌面图标点击需要在AppDelegate里面进行代码编写。1、创建方式123456789101112131415161718192021/** type 唯一标示r符* localizedTitle 标题* localizedSubtitle 副标题* icon UIApplicationShortcutIcon对象* userInfo 传递信息*/// 使用系统提供的图标生成UIApplicationShortcutIcon对象UIApplicationShortcutItem *shoreItem1 = [[UIApplicationShortcutItem alloc] initWithType:@"type1"localizedTitle:@"标题"localizedSubtitle:@"副标题"icon:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeCompose]userInfo:nil];// 使用自定义图片生成UIApplicationShortcutIcon对象UIApplicationShortcutItem *shoreItem2 = [[UIApplicationShortcutItem alloc] initWithType:@"type2"localizedTitle:@"标题2"localizedSubtitle:@"副标题2"icon:[UIApplicationShortcutIcon iconWithTemplateImageName:@"验证码"]userInfo:nil];[UIApplication sharedApplication].shortcutItems = @[shoreItem1, shoreItem2]; 注：系统的UIApplicationShortcutIcon样式，自己去研究吧！点击这个是官方地址 2、点击回调，可以根据shortcutItem.type 进行判断点击的是哪个item123- (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler &#123;NSLog(@"点击了%@", shortcutItem);&#125; 应用内，点击进行页面操作1、遵循代理UIViewControllerPreviewingDelegate 2、判断设备是否支持123456if (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable)&#123;[self registerForPreviewingWithDelegate:self sourceView:self.view];NSLog(@"3D Touch 可用!");&#125; else &#123;NSLog(@"3D Touch 不可用!");&#125; 3、实现代理方法12345678- (nullable UIViewController *)previewingContext:(id &lt;UIViewControllerPreviewing&gt;)previewingContext viewControllerForLocation:(CGPoint)location &#123;NextViewController *vc = [[NextViewController alloc] init];return vc;&#125;-(void)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext commitViewController:(UIViewController *)viewControllerToCommit &#123;[self showViewController:viewControllerToCommit sender:self];&#125; 4、在需要显示的页面里面调用- (NSArray&lt;id&lt;UIPreviewActionItem&gt;&gt; *)previewActionItems添加Items12345678910111213141516- (NSArray&lt;id&lt;UIPreviewActionItem&gt;&gt; *)previewActionItems &#123;UIPreviewAction *action1 = [UIPreviewAction actionWithTitle:@"标题1" style:UIPreviewActionStyleDefault handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) &#123;NSLog(@"click---标题1");&#125;];UIPreviewAction *action2 = [UIPreviewAction actionWithTitle:@"标题2" style:UIPreviewActionStyleSelected handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) &#123;NSLog(@"click---标题2");&#125;];UIPreviewAction *action3 = [UIPreviewAction actionWithTitle:@"标题3" style:UIPreviewActionStyleDestructive handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) &#123;NSLog(@"click---标题3");&#125;];NSArray *actions = @[action1,action2,action3];return actions;&#125; 温馨提示 点击App图标显示最分享按钮，是苹果给上架App添加的 点击分享的效果]]></content>
  </entry>
  <entry>
    <title><![CDATA[Runtime-消息转发]]></title>
    <url>%2F2019%2F03%2F19%2FRuntime-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[iOS 方法的动态解析和消息转发 以创建的Message类为示例Message.h1234567@interface Message : NSObject- (void)sendMessage:(NSString *)message;+ (void)sendClassMessage:(NSString *)message;@end Message.m123@implementation Message@end 动态方法解析征询接收者所属的类，是否需要动态添加类方法或实例方法，来处理这个未找到的方法。 首先判断是否实现了 resolveInstanceMethod，如果没有实现，进入下一步处理； 如果实现了，调用 resolveInstanceMethod，获取返回值； 如果返回值为 YES，表示 resolveInstanceMethod 声称它已经提供了 selector 的实现，因此再次查找 method list，如果找到对应的 IMP，则返回该实现，否则提示警告信息，进入下一步处理； 如果返回值为 NO，进入下一步处理；1. 对象方法通过+ (BOOL)resolveInstanceMethod:(SEL)sel;方法进行解析1234567891011+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(sendMessage:)) &#123; class_addMethod([self class], sel, (IMP)innerSenderMessageMetod, "v@:@"); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;void innerSenderMessageMetod(id obj, SEL _cmd) &#123; NSLog(@"对象方法，动态解析");&#125; 2. 类方法通过+ (BOOL)resolveClassMethod:(SEL)sel;方法进行解析1234567891011+ (BOOL)resolveClassMethod:(SEL)sel &#123; if (sel == @selector(sendClassMessage:)) &#123; class_addMethod(object_getClass(self), sel, (IMP)innerSenderClassMessageMetod, "v@:@"); return YES; &#125; return [super resolveClassMethod:sel];&#125;void innerSenderClassMessageMetod(id obj, SEL _cmd) &#123; NSLog(@"类方法，动态解析");&#125; 重定向如果没有动态添加方法，则会进入此阶段，此时询问是否要将这条消息转发给其他的对象，来处理这个方法。如果返回nil，即表示不转发给其他对象，此时会进入第3阶段创建了一个备用类MessageTempMessageTemp.h12345@interface MessageTemp : NSObject- (void)sendMessage:(NSString *)message;- (void)sendClassMessage:(NSString *)message;@end MessageTemp.m12345678@implementation MessageTemp- (void)sendMessage:(NSString *)message &#123; NSLog(@"备用Message，解析对象方法");&#125;- (void)sendClassMessage:(NSString *)message &#123; NSLog(@"备用Message，解析类方法");&#125;@end 1. 对象方法123456- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector == @selector(sendMessage:)) &#123; return [MessageTemp new]; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 2. 类方法123456+ (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector == @selector(sendClassMessage:)) &#123; return [MessageTemp new]; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 消息转发当 forwardingTargetForSelector: 方法未做出任何响应的话，会来到消息转发流程。消息转发时会首先调用 methodSignatureForSelector: 方法，在方法内部生成 NSMethodSignature 类型的方法签名对象。在生成签名对象时，可以指定 target 和 SEL，可以将这两个参数换成其他参数，将消息转发给其他对象。 1. 对象方法1234567891011121314- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; if ([anInvocation selector] == @selector(sendMessage:)) &#123; [anInvocation invokeWithTarget:[MessageTemp new]]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if (aSelector == @selector(sendMessage:)) &#123; return [NSMethodSignature signatureWithObjCTypes:"v@:@"]; &#125; return [super methodSignatureForSelector:aSelector];&#125; 2. 类方法1234567891011121314+ (void)forwardInvocation:(NSInvocation *)anInvocation &#123; if ([anInvocation selector] == @selector(sendClassMessage:)) &#123; [anInvocation invokeWithTarget:[MessageTemp new]]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125;+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if (aSelector == @selector(sendClassMessage:)) &#123; return [NSMethodSignature signatureWithObjCTypes:"v@:@"]; &#125; return [super methodSignatureForSelector:aSelector];&#125; 应用场景 适用于把操作给另外一个类来实现 利用分类，防止应用程序因为未处理消息而崩溃 Jspatch Aspects BlocksKit]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS代码块(Snippet)]]></title>
    <url>%2F2019%2F03%2F13%2F%E4%BB%A3%E7%A0%81%E5%9D%97(Snippet)%2F</url>
    <content type="text"><![CDATA[代码块(Snippet)，方便了代码快速创建。 管理：在新版Xcode中管理页面在编译器的右上角 添加：选中代码鼠标右击 编辑 Title：标题。 Summary：描述文字。 Platform：可以使用的平台（如iOS、Mac OS）。 Language：可以在哪些语言中使用（如 Objective-C、Swift）。 Completion Shortcut：快捷方式，以字母开头（支持少数符号，如@）。 Completion Scopes：作用范围，一般写在正确的位置拖动即可，Xcode会自行选择好。属性12345@property (nonatomic, strong) &lt;#ClassName#&gt; *&lt;#class#&gt;; ///&lt; &lt;#注释#&gt;@property (nonatomic, assign) &lt;#DataType#&gt; &lt;#name#&gt;; ///&lt; &lt;#注释#&gt;@property (nonatomic, copy) &lt;#ClassName#&gt; *&lt;#name#&gt;; ///&lt; &lt;#注释#&gt;@property (nonatomic, weak) id&lt;&lt;#delegateOrDataSouce#&gt;&gt; &lt;#delegateOrDataSouce#&gt;; ///&lt; &lt;#注释#&gt;@property (nonatomic, weak) &lt;#Class#&gt; *&lt;#name#&gt;; ///&lt; &lt;#注释#&gt; 常用注释 顶部注释 1/** &lt;#属性注释#&gt; */ 右侧注释 1///&lt; &lt;#注释#&gt; 简述顶部注释 123/** &lt;#简要描述#&gt; * &lt;#详细描述#&gt; */ Pragma 有分割线 1#pragma mark &lt;#mark#&gt; 无分割线 1#pragma mark - &lt;#mark&gt; 或 // MARK: &lt;#mark#&gt; Warning(警告) 1#warning &lt;#message#&gt; ???(不确定) 1// ???: &lt;#???#&gt; !!!(警告) 1// !!!: &lt;#???#&gt; FIXME(需要修改的地方) 1// FIXME: &lt;#Fix详情#&gt; 常用方法 123456789#pragma mark - 页面控件配置- (void)setupSubViewsProperties &#123; &#125;#pragma mark - 页面控件布局- (void)setupSubViewsConstraint &#123; &#125; 枚举 1234567typedef NS_ENUM(NSInteger, &lt;#TypeName#&gt;) &#123; &#125;;typedef NS_OPTIONS(NSUInteger, &lt;#TypeName#&gt;) &#123; &#125;; IFDEBUG 12345#if DEBUG&lt;#TODO#&gt;#else&lt;#TODO#&gt;#endif 快捷初始化UILabel 123456UILabel *l = [[UILabel alloc] init];l.font = [UIFont &lt;#font#&gt;];l.text = @"&lt;#conent#&gt;";l.textColor = [UIColor &lt;#textColor#&gt;];l.numberOfLines = 0;[&lt;#view#&gt; addSubview:l]; 快捷初始化UIButton 12345678UIButton *b = [UIButton buttonWithType:UIButtonTypeCustom];b.backgroundColor = [UIColor &lt;#backgroundColor#&gt;];b.titleLabel.font = [UIFont &lt;#font#&gt;];[b setTitle:&lt;#title#&gt; forState:UIControlStateNormal];[b setTitleColor:[UIColor &lt;#titleColor#&gt;] forState:UIControlStateNormal];[b setImage:[UIImage imageNamed:&lt;#(nonnull NSString *)#&gt;] forState:UIControlStateNormal][b addTarget:self action:@selector(didTapped&lt;#Button Name#&gt;:) forControlEvents:UIControlEventTouchUpInside];[&lt;#view#&gt; addSubview:b]; UIButton 点击事件 1234/** &lt;#ButtonName#&gt;点击事件 */- (void)didTapped&lt;#ButtonName#&gt;:(UIButton *)sender &#123; &#125; Notification事件 1234/** &lt;#Notification Name#&gt;通知事件 */- (void)didReceive&lt;#Notification Name#&gt;:(NSNotification *)notification &#123; &#125; UIGestureRecognizer触摸事件 1234/** &lt;#GestureRecognizer Name#&gt;触摸事件 */- (void)didRecognized&lt;#GestureRecognizer Name#&gt;:(UIGestureRecognizer *)recognizer &#123; &#125; 结束语这也是为了个人意见，其他还有很多可以做成代码块的，例如CGD，TableViewDataSource等等，希望短短的文章可以让你代码可以写的更好。]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS工具类-时间差]]></title>
    <url>%2F2019%2F02%2F26%2FiOS%E5%B7%A5%E5%85%B7%E7%B1%BB-%E6%97%B6%E9%97%B4%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[最近想写点日常使用的工具类，方便开发。首先想到就是时间之类的问题，所以打开Xocde，进行代码编辑。这个代码考虑不是很完全，日后有时间再进行修改补充。 接口文件我使用的类名称为DateHandleUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354NS_ASSUME_NONNULL_BEGINtypedef NS_ENUM(NSInteger, WeiBoTimeStyle) &#123; WeiBoTimeStyleSecond, WeiBoTimeStyleMillisecond&#125;;@interface DateHandleUtils : NSObject/** 根据时间返回文字时间戳 @param timeInterval 比较时间 @param style 时间戳格式 @return `刚刚`、`10秒前`、`10分钟前`、`1小时前`等等 */+ (NSString *)weiboTimeWithPublicTime:(NSTimeInterval)timeInterval timeStyel:(WeiBoTimeStyle)style;/** * 当前时间时间戳 * @return 毫秒的时间戳 */+ (NSTimeInterval)currentMilliSecondTimeInterval;/** * 当前时间时间戳 * @return 秒的时间戳 */+ (NSTimeInterval)currentSecondTimeInterval;/** * 根据时间戳获取时间差 * @param startTime 开始时间的时间戳 @param endTime 结束时间的时间戳 @return 返回差值，单位为秒 @warning 传值格式为：毫秒级时间戳 */+ (NSTimeInterval)timeDifferenceOfMillisecondWithStartTimeInterval:(NSTimeInterval)startTime endTimeInterval:(NSTimeInterval)endTime;/** * 根据时间戳获取时间差 * @param startTime 开始时间的时间戳 @param endTime 结束时间的时间戳 @return 返回差值，单位为秒 @warning 传值格式为：秒级时间戳 */+ (NSTimeInterval)timeDifferenceOfSecondsWithStartTimeInterval:(NSTimeInterval)startTime endTimeInterval:(NSTimeInterval)endTime;@endNS_ASSUME_NONNULL_END 实现文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@implementation DateHandleUtils+ (NSString *)weiboTimeWithPublicTime:(NSTimeInterval)timeInterval timeStyel:(WeiBoTimeStyle)style &#123; NSTimeInterval interval; switch (style) &#123; case WeiBoTimeStyleSecond: interval = [DateHandleUtils timeDifferenceOfSecondsWithStartTimeInterval:timeInterval endTimeInterval:[DateHandleUtils currentSecondTimeInterval]]; break; case WeiBoTimeStyleMillisecond: interval = [DateHandleUtils timeDifferenceOfMillisecondWithStartTimeInterval:timeInterval endTimeInterval:[DateHandleUtils currentMilliSecondTimeInterval]]; break; default: break; &#125; if (interval &lt; 10) &#123; return @"刚刚"; &#125; else if (interval &lt; 60) &#123; return [NSString stringWithFormat:@"%.f秒前", interval]; &#125; else if (interval / 60 &lt; 60) &#123; return [NSString stringWithFormat:@"%.f分钟前", interval / 60]; &#125; else if (interval / 60 / 60 &lt; 24) &#123; return [NSString stringWithFormat:@"%.f小时前", interval / 60 / 60 - 1]; &#125; else if (interval / 60 / 60 / 24 &lt; 30) &#123; return [NSString stringWithFormat:@"%.f天前", interval / 60 / 60 / 24]; &#125; else if (interval / 60 / 60 / 24 / 30 &lt; 12) &#123; return [NSString stringWithFormat:@"%.f月前", interval / 60 / 60 / 24 / 30]; &#125; else if (interval / 60 / 60 / 24 / 30 / 12 &gt;= 1)&#123; return [NSString stringWithFormat:@"%.f年前", interval / 60 / 60 / 24 / 30 / 12]; &#125; else &#123; return @"未知时间"; &#125;&#125;+ (NSTimeInterval)currentMilliSecondTimeInterval &#123; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setDateStyle: NSDateFormatterMediumStyle]; [formatter setTimeStyle: NSDateFormatterShortStyle]; [formatter setDateFormat: @"YYYY-MM-dd HH:mm:ss SSS"]; NSTimeZone *timeZone = [NSTimeZone timeZoneWithName: @"Asia/Shanghai"]; [formatter setTimeZone: timeZone]; NSDate *datenow = [NSDate date]; return [datenow timeIntervalSince1970] * 1000;&#125;+ (NSTimeInterval)currentSecondTimeInterval &#123; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setDateStyle: NSDateFormatterMediumStyle]; [formatter setTimeStyle: NSDateFormatterShortStyle]; [formatter setDateFormat: @"YYYY-MM-dd HH:mm:ss SSS"]; NSTimeZone *timeZone = [NSTimeZone timeZoneWithName: @"Asia/Shanghai"]; [formatter setTimeZone: timeZone]; NSDate *datenow = [NSDate date]; return [datenow timeIntervalSince1970];&#125;+ (NSTimeInterval)timeDifferenceOfMillisecondWithStartTimeInterval:(NSTimeInterval)startTime endTimeInterval:(NSTimeInterval)endTime &#123; if (startTime &lt; endTime) &#123; return (endTime - startTime) / 1000; &#125; else &#123; return (startTime - endTime) / 1000; &#125;&#125;+ (NSTimeInterval)timeDifferenceOfSecondsWithStartTimeInterval:(NSTimeInterval)startTime endTimeInterval:(NSTimeInterval)endTime &#123; if (startTime &lt; endTime) &#123; return (endTime - startTime); &#125; else &#123; return (startTime - endTime); &#125;&#125;@end 使用方式都是类方法，用的时候直接使用类名调用就可以了(实例：[DateHandleUtils currentMilliSecondTimeInterval];);]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS开发技巧-不断更新中]]></title>
    <url>%2F2019%2F01%2F24%2F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1、PrefixHeader导入位置写法1$(SRCROOT)/$(PROJECT_NAME)/&lt;#文件所在文件夹名称#&gt;/PrefixHeader.pch 2、隐藏导航栏的两种方式1234567891011121314151617181920212223242526272829//方式一 《推荐》//在需要隐藏的viewController中遵循&lt;UINavigationControllerDelegate&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; // 设置导航控制器的代理为self self.navigationController.delegate = self;&#125;#pragma mark - UINavigationControllerDelegate// 将要显示控制器- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; // 判断要显示的控制器是否是自己 BOOL isShowHomePage = [viewController isKindOfClass:[self class]]; [self.navigationController setNavigationBarHidden:isShowHomePage animated:YES];&#125;//方式二- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:YES animated:YES];&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [self.navigationController setNavigationBarHidden:NO animated:YES];&#125; 3、TabBarItem要求只显示图片不显示文字12// self 表示需要设置样式的控制器[self.tabBarItem setImageInsets:UIEdgeInsetsMake(6, 0, -6, 0)]; 4、TableView或CollectionView单选1234567891011&lt;!--步骤一、 声明一个全局变量--&gt;@property (nonatomic, assign) NSInteger selectedIndex;&lt;!--步骤二、TableView或CollectionView点击事件的方法中保存点击的index，并刷新--&gt;self.selectedIndex = indexPath.row;[collectionView reloadData];或[tableView reloadData];&lt;!--步骤三、在cellForItemAtIndexPath或cellForRowAtIndexPath方法中判断是否是所保存的index--&gt;if (self.selectedIndex == indexPath.row) &#123; // 设置选中样式&#125; else &#123; // 设置成默认样式 &#125; 5、怎么区分真机还是模拟器1234567#if TARGET_IPHONE_SIMULATOR NSLog(@"run on simulator"); #define SIMULATOR_TEST#else //不定义SIMULATOR_TEST这个宏 NSLog(@"run on device"); #endif 6、if Debug12345#ifdef DEBUG // do sth#else // do sth#endif 7、一键清理所有模拟器安装过的APP12// 先关闭所有模拟器 在终端中输入下面命令即可xcrun simctl erase all 8、SDWebImage清理缓存1234- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; [[[SDWebImageManager sharedManager] imageCache] clearMemory];&#125; 9、UITableView的HeaderView下拉放大123456789101112131、View1:作为显示View2、View2:作为tableView的tableHeaderView，并添加View1，View2的大小和View1大小相同.3、在UIScrollViewDelegate方法中进行设计- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; CGFloat width = UIScreen.mainScreen.bounds.size.width; CGFloat viewHeight = kScreenWidth * 0.5; // View1的初始高度 CGFloat yOffset = scrollView.contentOffset.y; if (yOffset &lt; 0) &#123; CGFloat totalOffset = viewHeight + ABS(yOffset); CGFloat f = totalOffset / viewHeight; self.headerView.frame = CGRectMake(- (width * f - width) / 2, yOffset, width * f, totalOffset); &#125;&#125; 10、Masonry制作就宫格1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//Objective-C ----&gt; Masonry/** 多视图布局 @param viewArray 视图数组 @param column 列数 @param tbSpeace 视图上下间距 @param lrSpeace 视图左右间距 @param topSpeace 和父视图上间距 @param lrSuperViewSpeace 父视图左右间距 @param superView 父视图 @param viewHeight 视图高度 */- (void)wd_masLayoutSubViewsWithViewArray:(NSArray&lt;UIView *&gt; *)viewArray columnOfRow:(NSInteger)column topBottomOfItemSpeace:(CGFloat)tbSpeace leftRightItemSpeace:(CGFloat)lrSpeace topOfSuperViewSpeace:(CGFloat)topSpeace leftRightSuperViewSpeace:(CGFloat)lrSuperViewSpeace addToSubperView:(UIView *)superView viewHeight:(CGFloat)viewHeight&#123; CGFloat viewWidth = superView.bounds.size.width; CGFloat itemWidth = (viewWidth - lrSuperViewSpeace * 2 - (column - 1) * lrSpeace) / column * 1.0f; CGFloat itemHeight = viewHeight; UIView *last = nil; for (int i = 0; i &lt; viewArray.count; i++) &#123; UIView *item = viewArray[i]; [superView addSubview:item]; [item mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.width.mas_equalTo(itemWidth); make.height.mas_equalTo(itemHeight); CGFloat top = topSpeace + (i / column) * (itemHeight + tbSpeace); make.top.mas_offset(top); if (!last || (i % column) == 0) &#123; make.left.mas_offset(lrSuperViewSpeace); &#125;else&#123; make.left.mas_equalTo(last.mas_right).mas_offset(lrSpeace); &#125; &#125;]; last = item; &#125;&#125; 11、Snapkit制作九宫格1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Swift ----&gt; SnapKit /// 多视图布局 /// /// - Parameters: /// - viewArray: 视图数组 /// - columnOfRow: 列数 /// - topBottomOfItemSpeace: 视图上下间距 /// - leftRightItemSpeace: 视图左右间距 /// - topOfSuperViewSpeace: 和父视图上间距 /// - leftRightSuperViewSpeace: 父视图左右间距 /// - addToSubperView: 父视图 /// - viewHeight: 视图高度 func wd_masLayoutSubViews(viewArray:Array&lt;UIView&gt;, columnOfRow:Int, topBottomOfItemSpeace:CGFloat, leftRightItemSpeace:CGFloat, topOfSuperViewSpeace:CGFloat, leftRightSuperViewSpeace:CGFloat, addToSubperView:UIView, viewHeight:CGFloat) -&gt; Void &#123; let viewWidth = addToSubperView.bounds.width let tempW = leftRightSuperViewSpeace * 2 + CGFloat(columnOfRow - 1) * leftRightItemSpeace let itemWidth = (viewWidth - tempW) / CGFloat(columnOfRow) let itemHeight = viewHeight print(leftRightSuperViewSpeace,leftRightItemSpeace,itemWidth) var lastView:UIView? for (index) in viewArray.enumerated() &#123; let item = viewArray[i] addToSubperView.addSubview(item) item.snp.makeConstraints &#123; (make) in make.width.equalTo(itemWidth) make.height.equalTo(itemHeight) let top = topOfSuperViewSpeace + CGFloat(i / columnOfRow) * (itemHeight + topBottomOfItemSpeace) make.top.equalTo(top) if !(lastView != nil) || i%columnOfRow == 0 &#123; make.left.equalTo(leftRightSuperViewSpeace) &#125; else &#123; make.left.equalTo((lastView?.snp.right)!).offset(leftRightItemSpeace) &#125; lastView = item &#125; &#125; &#125; 12、沉浸式TableView(ScrollView、CollectionView)12345if (@available(iOS 11.0, *)) &#123; self.tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;&#125; else &#123; self.automaticallyAdjustsScrollViewInsets = false;&#125; 13、通过身份证计算年龄1234567891011121314151617181920212223242526272829303132333435363738/** 通过身份证计算年龄 */- (NSString *)calculationAgeWithBirthday: (NSString *)birthday &#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSDate *nowDate = [NSDate date]; NSString *birth = birthday; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc]init]; [dateFormatter setDateFormat:@"yyyy-MM-dd"]; NSDate *birthDay = [dateFormatter dateFromString:birth]; unsigned int unitFlags = NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay; NSDateComponents *date = [calendar components:unitFlags fromDate:birthDay toDate:nowDate options:0]; if ([date year] &gt; 0) &#123; return [NSString stringWithFormat:@"%ld岁", (long)[date year]]; &#125; else if([date month] &gt; 0) &#123; return [NSString stringWithFormat:@"%ld月", (long)[date month]]; &#125; else if([date day] &gt; 0)&#123; return [NSString stringWithFormat:@"%ld天", (long)[date day]]; &#125; else &#123; return @"0天"; &#125;&#125;- (NSString *)ageStrFromIdentityCard:(NSString *)numberStr &#123; NSString *dateSt; NSMutableString *dateS; if (numberStr.length &gt; 15) &#123; dateSt = [numberStr substringWithRange:NSMakeRange(6, 8)]; dateS = [NSMutableString stringWithFormat:@"%@", dateSt]; [dateS insertString:@"-" atIndex:4]; [dateS insertString:@"-" atIndex:7]; &#125; else &#123; // 只考虑 19开头的15位的身份证号 dateSt = [NSString stringWithFormat:@"19%@",[numberStr substringWithRange:NSMakeRange(6, 6)]]; dateS = [NSMutableString stringWithFormat:@"%@", dateSt]; [dateS insertString:@"-" atIndex:4]; [dateS insertString:@"-" atIndex:7]; &#125; return [self calculationAgeWithBirthday:dateS];&#125; 14、利用runtime自动归档123456789101112131415161718192021222324252627// 导入头文件#import &lt;objc/runtime.h&gt;// 遵循协议&lt;NSCoding&gt;// 实现方法- (id)initWithCoder:(NSCoder *)aDecoder &#123; if (self = [super init]) &#123; unsigned int outCount; Ivar * ivars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar ivar = ivars[i]; NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)]; [self setValue:[aDecoder decodeObjectForKey:key] forKey:key]; &#125; &#125; return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder &#123; unsigned int outCount; Ivar * ivars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar ivar = ivars[i]; NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)]; [aCoder encodeObject:[self valueForKey:key] forKey:key]; &#125;&#125; 15、优化Snipkit 没有distributeViewsAlong12]]></content>
  </entry>
  <entry>
    <title><![CDATA[AVPlayer封装]]></title>
    <url>%2F2019%2F01%2F11%2FAVPlayer%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[最近在写关于音视频播放的案例，所以就趁机会研究了一下AVPlayer的内容。我封装的目前只能播放网络音视频。还未添加缓存，以后找机会研究一下再更新。代码中提供了音视频的上一曲、下一曲、暂停、开始、停止、单曲播放、顺序播放、随机播放等功能。代码写的不好，仅供参考~ 代码接口文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#import &lt;Foundation/Foundation.h&gt;#import &lt;AVFoundation/AVFoundation.h&gt;NS_ASSUME_NONNULL_BEGIN// 当前播放器的播放形式typedef NS_ENUM(NSInteger, MediaPlayType) &#123; MediaPlayTypeCycle, ///&lt; 顺序 MediaPlayTypeSingle, ///&lt; 单曲循环 MediaPlayTypeRandom ///&lt; 随机播放&#125;;// 当前播放器的播放状态typedef NS_ENUM(NSInteger, MediaPlayStatus) &#123; MediaPlayStatusStop, ///&lt; 停止播放 MediaPlayStatusPause, ///&lt; 暂停播放 MediaPlayStatusPlaying ///&lt; 正在播放&#125;;// 媒体加载状态typedef NS_ENUM(NSInteger, MediaLoadStatus) &#123; MediaLoadStatusReadyToPlay, ///&lt; 准备播放 MediaLoadStatusUnknown, ///&lt; 未知 MediaPlayStatusFailed ///&lt; 失败&#125;;@class MediaPlyerManager;@protocol MediaPlyerManagerDelegate &lt;NSObject&gt;@optional// 数据加载状态 根据状态进行播放或其他操作- (void)MediaPlayer:(MediaPlyerManager *)playerManager playerItemStatus:(MediaLoadStatus)status;// 缓冲进度- (void)MediaPlayer:(MediaPlyerManager *)playerManager netBufferValue:(CGFloat)value;// 缓冲是否足够播放- (void)MediaPlayer:(MediaPlyerManager *)playerManager bufferHasEnough:(BOOL)enough;// 当前播放的时间- (void)MediaPlayer:(MediaPlyerManager *)playerManager currentPlayTime:(NSString *)time currentPlayTimeValue:(CGFloat)value;// 播放总时间- (void)MediaPlayer:(MediaPlyerManager *)playerManager mediaEndTime:(NSString *)time mediaEndTimeValue:(CGFloat)value;// 播放结束- (void)MediaPlayerCurrentMediaPlayFinish:(MediaPlyerManager *)playerManager;// 播放状态- (void)MediaPlayer:(MediaPlyerManager *)playerManager playeStatus:(MediaPlayStatus)status;// 获取数据切换时获取正在播放的URL和当前的index- (void)MediaPlayer:(MediaPlyerManager *)playerManager currentUrl:(NSString *)url currentIndex:(NSInteger)index;// 为了配合手机后台播放 实时获取播放的进度，总的时间，当前的index&lt;通过index获取图片等信息&gt;- (void)MediaPlayer:(MediaPlyerManager *)playerManager currentProgressValue:(CGFloat)value totalValue:(CGFloat)totalValue currentIndex:(NSInteger)index;@endtypedef MediaPlyerManager *(^playerCurrentTime)(NSString *time);@interface MediaPlyerManager : NSObject@property (nonatomic, strong, readonly) AVPlayer *mediaPlayer; ///&lt; 播放器@property (nonatomic, strong, readonly) AVPlayerItem *meidaPlayerItem; ///&lt; 播放器的CurrentItem@property (nonatomic, strong, readonly) NSMutableArray&lt;NSString*&gt; *dataUrlArray; ///&lt; 正在播放的列表数据@property (nonatomic, assign, readonly) MediaPlayType playType; ///&lt; 当前播放类型@property (nonatomic, assign, readonly) MediaPlayStatus playStatus; ///&lt; 当前播放状态@property (nonatomic, assign, readonly) NSInteger currentIndex; ///&lt; 当前播放的索引@property (nonatomic, assign, readonly) BOOL isPlaying; ///&lt; 是否在播放@property (nonatomic, assign, readonly) CGFloat curentPlayTimeValue; ///&lt; 当前播放时间值@property (nonatomic, copy, readonly) NSString *curentPlayTime; ///&lt; 当前播放时间@property (nonatomic, assign, readonly) CGFloat endPlayTimeValue; ///&lt; 当前播放时间值@property (nonatomic, copy, readonly) NSString *endPlayTime; ///&lt; 当前播放时间+ (instancetype)defaultManager;/** 列表播放 ⚠️&lt;默认不自动播放&gt; @param urls 文件路径数组 @param delegate 回调代理 @return MediaPlyerManager */- (MediaPlyerManager *)playerWithUrls:(NSArray&lt;NSString *&gt; *)urls actionWithDelegate:(id&lt;MediaPlyerManagerDelegate&gt;)delegate;/** 单个音视频播放 ⚠️&lt;默认不自动播放&gt; @param url 文件路径 @param delegate 回调代理 @return MediaPlyerManager */- (MediaPlyerManager *)playerWithUrl:(NSString *)url actionWithDelegate:(id&lt;MediaPlyerManagerDelegate&gt;)delegate;/** 开始播放 */- (void)play;/** 暂停播放 */- (void)pause;/** 停止播放 */- (void)stop;/** 下一曲 */- (void)next;/** 上一曲 */- (void)previous;/** 指定进度开始播放 @param progress 进度百分比 */- (void)setupPlayerSeekToProgress:(CGFloat)progress;/** 制定播放类型 @param type 类型 */- (void)setupMediaPlayerType:(MediaPlayType)type;/** 指定播放的index @param index 索引 */- (void)setupPlayerIndex:(NSInteger)index;/** 添加数据 @param files 文件数组 @param index 索引 */- (void)insertMediaFile:(NSArray&lt;NSString *&gt; *)files atIndex:(NSInteger)index;/** 移除全部数据 */- (void)removeAllFiles;/** 移除索引中的单个数据 @param index 索引 */- (void)removeObjectAtIndex:(NSInteger)index;/** 设置锁屏样式 @param coverImage 专辑图片 @param size 显示大小 @param title 标题 @param author 专辑作者 @param album 专辑名称 @param currentTime 当前播放时间 @param duration 播放总时长 */- (void)setupLockScreenPlayInfo:(UIImage *)coverImage imageSize:(CGSize)size title:(NSString *)title ahthor:(NSString *)author album:(NSString *)album currentPlayTime:(CGFloat)currentTime duration:(CGFloat)duration;@endNS_ASSUME_NONNULL_END 代码实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#import "MediaPlyerManager.h"#import &lt;MediaPlayer/MediaPlayer.h&gt;@interface MediaPlyerManager ()@property (nonatomic, strong, readwrite) NSMutableArray&lt;NSString *&gt; *dataUrlArray;@property (nonatomic, strong, readwrite) AVPlayer *mediaPlayer;@property (nonatomic, assign, readwrite) BOOL isPlaying;@property (nonatomic, strong, readwrite) AVPlayerItem *meidaPlayerItem;@property (nonatomic, assign, readwrite) MediaPlayType playeType;@property (nonatomic, assign, readwrite) NSInteger currentIndex;@property (nonatomic, assign, readwrite) MediaPlayStatus playStatus;@property (nonatomic, assign, readwrite) CGFloat curentPlayTimeValue;@property (nonatomic, copy, readwrite ) NSString *curentPlayTime;@property (nonatomic, assign, readwrite) CGFloat endPlayTimeValue;@property (nonatomic, copy, readwrite ) NSString *endPlayTime;@property (nonatomic, weak ) id &lt;MediaPlyerManagerDelegate&gt; delegate;@end@implementation MediaPlyerManager+ (instancetype)defaultManager &#123; static dispatch_once_t onceToken; static MediaPlyerManager *manger; dispatch_once(&amp;onceToken, ^&#123; manger = [[MediaPlyerManager alloc] init]; &#125;); return manger;&#125;#pragma mark - 初始化- (MediaPlyerManager *)playerWithUrl:(NSString *)url actionWithDelegate:(id&lt;MediaPlyerManagerDelegate&gt;)delegate &#123; [self playerWithUrls:@[url] actionWithDelegate:delegate]; return self;&#125;- (MediaPlyerManager *)playerWithUrls:(NSArray&lt;NSString *&gt; *)urls actionWithDelegate:(id&lt;MediaPlyerManagerDelegate&gt;)delegate &#123; self.delegate = delegate; self.currentIndex = 0; self.dataUrlArray = [NSMutableArray array]; NSMutableArray *array = [NSMutableArray arrayWithCapacity:urls.count]; for (NSString *urlStr in urls) &#123; [array addObject:[self createPlayerItemWithUrl:urlStr]]; [self.dataUrlArray addObject:urlStr]; &#125; self.playeType = MediaPlayTypeCycle; self.mediaPlayer = [[AVPlayer alloc] initWithPlayerItem:array.firstObject]; self.meidaPlayerItem = self.mediaPlayer.currentItem; [self getCurrentIndex:self.currentIndex]; [self addObserver]; __weak typeof(self) weakself = self; [self.mediaPlayer addPeriodicTimeObserverForInterval:CMTimeMake(1, 1) queue:NULL usingBlock:^(CMTime time) &#123; NSString *currentString = [weakself getStringFromCMTime:time]; weakself.curentPlayTime = currentString; weakself.curentPlayTimeValue = (CGFloat)time.value/time.timescale; #pragma mark - 获取当前播放时间 if (weakself.delegate &amp;&amp; [weakself.delegate respondsToSelector:@selector(MediaPlayer:currentPlayTime:currentPlayTimeValue:)]) &#123; [weakself.delegate MediaPlayer:weakself currentPlayTime:currentString currentPlayTimeValue:(CGFloat)time.value/time.timescale]; &#125;#pragma mark - 实时获取播放信息 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:currentProgressValue:totalValue:currentIndex:)]) &#123; [weakself.delegate MediaPlayer:weakself currentProgressValue:weakself.curentPlayTimeValue totalValue:weakself.endPlayTimeValue currentIndex:weakself.currentIndex]; &#125; &#125;]; return self;&#125;#pragma mark - 播放结束- (void)playFinish:(NSNotification *)notification &#123; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayerCurrentMediaPlayFinish:)]) &#123; [self.delegate MediaPlayerCurrentMediaPlayFinish:self]; &#125; if (self.playeType == MediaPlayTypeSingle) &#123; [self.mediaPlayer seekToTime:kCMTimeZero]; [self play]; &#125; else &#123; if (self.currentIndex &lt; self.dataUrlArray.count - 1) &#123; self.currentIndex += 1; &#125; else &#123; self.currentIndex = 0; &#125; [self.mediaPlayer replaceCurrentItemWithPlayerItem:[self createPlayerItemWithUrl:self.dataUrlArray[self.currentIndex]]]; self.meidaPlayerItem = self.mediaPlayer.currentItem; [self getCurrentIndex:self.currentIndex]; [self play]; &#125;&#125;#pragma mark - KVO- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; AVPlayerItem *playerItem = object; if ([keyPath isEqualToString:@"status"]) &#123; MediaLoadStatus status = [change[@"new"] integerValue];#pragma mark - 获取媒体加载状态 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:playerItemStatus:)]) &#123; [self.delegate MediaPlayer:self playerItemStatus:status]; &#125; &#125; else if ([keyPath isEqualToString:@"loadedTimeRanges"]) &#123; NSArray * timeRanges = playerItem.loadedTimeRanges; CMTimeRange timeRange = [timeRanges.firstObject CMTimeRangeValue]; NSTimeInterval totalLoadTime = CMTimeGetSeconds(timeRange.start) \ + CMTimeGetSeconds(timeRange.duration); NSTimeInterval duration = CMTimeGetSeconds(playerItem.duration); NSTimeInterval scale = totalLoadTime/duration; #pragma mark - 获取媒体总时间 if ((CGFloat)duration/scale &gt;= 0) &#123; self.endPlayTime = [self getStringFromCMTime:playerItem.duration]; self.endPlayTimeValue = (CGFloat)duration/scale; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:mediaEndTime:mediaEndTimeValue:)]) &#123; [self.delegate MediaPlayer:self mediaEndTime:[self getStringFromCMTime:playerItem.duration] mediaEndTimeValue:(CGFloat)duration/scale]; &#125; &#125; #pragma mark - 缓冲百分比 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:netBufferValue:)]) &#123; [self.delegate MediaPlayer:self netBufferValue:scale]; &#125; &#125; else if ([keyPath isEqualToString:@"playbackBufferEmpty"]) &#123; #pragma mark - 缓冲不足够播放 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:bufferHasEnough:)]) &#123; [self.delegate MediaPlayer:self bufferHasEnough:false]; &#125; &#125; else if ([keyPath isEqualToString:@"playbackLikelyToKeepUp"]) &#123; #pragma mark - 缓冲足够播放 if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:bufferHasEnough:)]) &#123; [self.delegate MediaPlayer:self bufferHasEnough:true]; &#125; &#125;&#125;#pragma mark - 开始播放- (void)play &#123; [self.mediaPlayer play]; [self getPlayStatus:MediaPlayStatusPlaying];&#125;#pragma mark - 暂停播放- (void)pause &#123; [self.mediaPlayer pause]; [self getPlayStatus:MediaPlayStatusPause];&#125;#pragma mark - 停止播放- (void)stop &#123; [self.mediaPlayer replaceCurrentItemWithPlayerItem:nil]; [self getPlayStatus:MediaPlayStatusStop]; [self removeObserver];&#125;#pragma mark - 下一个- (void)next &#123; if (self.playeType == MediaPlayTypeRandom) &#123; self.currentIndex = (NSInteger)arc4random_uniform((int32_t)(self.dataUrlArray.count - 1)); &#125; else &#123; if (self.currentIndex == self.dataUrlArray.count - 1) &#123; self.currentIndex = 0; &#125; else &#123; self.currentIndex += 1; &#125; &#125; [self.mediaPlayer replaceCurrentItemWithPlayerItem:[self createPlayerItemWithUrl:self.dataUrlArray[self.currentIndex]]]; self.meidaPlayerItem = self.mediaPlayer.currentItem; [self getCurrentIndex:self.currentIndex]; [self addObserver];&#125;#pragma mark - 上一个- (void)previous &#123; if (self.playeType == MediaPlayTypeRandom) &#123; self.currentIndex = (NSInteger)arc4random_uniform((int32_t)(self.dataUrlArray.count - 1)); &#125; else &#123; if (self.currentIndex == 0) &#123; self.currentIndex = self.dataUrlArray.count - 1; &#125; else &#123; self.currentIndex -= 1; &#125; &#125; [self.mediaPlayer replaceCurrentItemWithPlayerItem:[self createPlayerItemWithUrl:self.dataUrlArray[self.currentIndex]]]; self.meidaPlayerItem = self.mediaPlayer.currentItem; [self getCurrentIndex:self.currentIndex]; [self addObserver];&#125;#pragma mark - 播放状态- (void)getPlayStatus:(MediaPlayStatus)status &#123; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:playeStatus:)]) &#123; [self.delegate MediaPlayer:self playeStatus:status]; &#125; self.playStatus = status; if (status == MediaPlayStatusPlaying) &#123; self.isPlaying = true; &#125; else &#123; self.isPlaying = false; &#125;&#125;#pragma mark - 根据index进行回调- (void)getCurrentIndex:(NSInteger)index &#123; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(MediaPlayer:currentUrl:currentIndex:)]) &#123; [self.delegate MediaPlayer:self currentUrl:self.dataUrlArray[index] currentIndex:index]; &#125;&#125;#pragma mark - 设置播放进度百分比- (void)setupPlayerSeekToProgress:(CGFloat)progress &#123; float timeValue = progress * CMTimeGetSeconds(self.mediaPlayer.currentItem.duration); [self.mediaPlayer seekToTime:CMTimeMake(timeValue, 1)];&#125;#pragma mark - 设置播放形式- (void)setupMediaPlayerType:(MediaPlayType)type &#123; self.playeType = type;&#125;#pragma mark - 播放指定index的媒体- (void)setupPlayerIndex:(NSInteger)index &#123; if (index &gt; (self.dataUrlArray.count - 1)) &#123; @throw [NSException exceptionWithName:@"越界错误" reason:@"index 不能超出URL数组的长度" userInfo:nil]; return; &#125; self.currentIndex = index; [self.mediaPlayer replaceCurrentItemWithPlayerItem:[self createPlayerItemWithUrl:self.dataUrlArray[self.currentIndex]]]; self.meidaPlayerItem = self.mediaPlayer.currentItem; [self getCurrentIndex:self.currentIndex];&#125;#pragma mark - 插入数据- (void)insertMediaFile:(NSArray&lt;NSString *&gt; *)files atIndex:(NSInteger)index &#123; for (NSString *urlStr in files) &#123; NSInteger i = [files indexOfObject:urlStr]; [self.dataUrlArray insertObject:urlStr atIndex:index + i]; &#125; if (index &lt; self.currentIndex) &#123; self.currentIndex += 1; &#125;&#125;#pragma mark - 删除数据- (void)removeAllFiles &#123; [self stop]; [self.dataUrlArray removeAllObjects]; self.dataUrlArray = [NSMutableArray array]; self.currentIndex = 0;&#125;- (void)removeObjectAtIndex:(NSInteger)index &#123; if (self.dataUrlArray.count == 1) &#123; [self removeAllFiles]; &#125; else &#123; [self.dataUrlArray removeObjectAtIndex:index]; if (index == self.currentIndex) &#123; if (index == 0) &#123; self.currentIndex = 0; [self next]; &#125; else &#123; self.currentIndex -= 1; &#125; &#125; else &#123; if (self.currentIndex &gt; index) &#123; self.currentIndex -= 1; &#125; &#125; &#125;&#125;#pragma mark - Utils- (NSString *)getStringFromCMTime:(CMTime)time &#123; float currentTimeValue = (CGFloat)time.value/time.timescale; NSDate * currentDate = [NSDate dateWithTimeIntervalSince1970:currentTimeValue]; NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian]; NSInteger unitFlags = NSCalendarUnitHour | NSCalendarUnitMinute | NSCalendarUnitSecond; NSDateComponents *components = [calendar components:unitFlags fromDate:currentDate]; if (currentTimeValue &gt;= 3600 ) &#123; return [NSString stringWithFormat:@"%02ld:%02ld:%02ld", (long)components.hour, (long)components.minute, (long)components.second]; &#125; else &#123; return [NSString stringWithFormat:@"%02ld:%02ld", (long)components.minute, (long)components.second]; &#125;&#125;- (void)addObserver &#123; // 监控状态属性 [self.meidaPlayerItem addObserver:self forKeyPath:@"status" options:(NSKeyValueObservingOptionOld|NSKeyValueObservingOptionNew) context:nil]; // 监控缓冲加载情况属性 [self.meidaPlayerItem addObserver:self forKeyPath:@"loadedTimeRanges" options:(NSKeyValueObservingOptionOld|NSKeyValueObservingOptionNew) context:nil]; // 监听缓冲不足够播放 [self.meidaPlayerItem addObserver:self forKeyPath:@"playbackBufferEmpty" options:NSKeyValueObservingOptionNew context:nil]; // 监听缓冲足够播放 [self.meidaPlayerItem addObserver:self forKeyPath:@"playbackLikelyToKeepUp" options:NSKeyValueObservingOptionNew context:nil]; // 获取是否播放结束 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(playFinish:) name:AVPlayerItemDidPlayToEndTimeNotification object:self.meidaPlayerItem];&#125;- (void)removeObserver &#123; [[NSNotificationCenter defaultCenter] removeObserver:self]; @try &#123; [self.meidaPlayerItem removeObserver:self forKeyPath:@"loadedTimeRanges"]; [self.meidaPlayerItem removeObserver:self forKeyPath:@"playbackBufferEmpty"]; [self.meidaPlayerItem removeObserver:self forKeyPath:@"playbackLikelyToKeepUp"]; [self.meidaPlayerItem removeObserver:self forKeyPath:@"status"]; &#125; @catch(NSException *exception) &#123; NSLog(@"%@", exception); &#125; &#125;#pragma mark - 设置锁屏样式- (void)setupLockScreenPlayInfo:(UIImage *)coverImage imageSize:(CGSize)size title:(NSString *)title ahthor:(NSString *)author album:(NSString *)album currentPlayTime:(CGFloat)currentTime duration:(CGFloat)duration &#123; Class playingInfoCenter = NSClassFromString(@"MPNowPlayingInfoCenter"); if (playingInfoCenter) &#123; NSMutableDictionary *songInfo = [[NSMutableDictionary alloc] init]; MPMediaItemArtwork *albumArt = [[MPMediaItemArtwork alloc] initWithBoundsSize:size requestHandler:^UIImage * _Nonnull(CGSize size) &#123; return coverImage; &#125;]; [songInfo setObject:title forKey:MPMediaItemPropertyTitle]; [songInfo setObject:author forKey:MPMediaItemPropertyArtist]; [songInfo setObject:album forKey:MPMediaItemPropertyAlbumTitle]; [songInfo setObject:albumArt forKey:MPMediaItemPropertyArtwork]; [songInfo setObject:[NSNumber numberWithDouble:currentTime] forKey:MPNowPlayingInfoPropertyElapsedPlaybackTime]; [songInfo setObject:[NSNumber numberWithDouble:duration] forKey:MPMediaItemPropertyPlaybackDuration]; [[MPNowPlayingInfoCenter defaultCenter] setNowPlayingInfo:songInfo]; &#125;&#125;- (AVPlayerItem *)createPlayerItemWithUrl:(NSString *)url &#123; return [AVPlayerItem playerItemWithURL:[NSURL URLWithString:url]];&#125;@end 提问本来相同使用AVQueuePlayer来进行列表播放的，但是当做单曲循环的时候遇到问题：通过通知监听播放完成，在通知的方法里进行具体操作，但是设置无效，直接播放的还是下一个文件。如果有人知道如何解决，帮忙回复一下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[RxSwift学习日常]]></title>
    <url>%2F2019%2F01%2F03%2FRxSwift%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%B8%B8%EF%BC%88%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Observable 介绍Observable Observable 这个类就是 Rx 框架的基础，我们可以称它为可观察序列。它的作用就是可以异步地产生一系列的 Event（事件），即一个 Observable 对象会随着时间推移不定期地发出 event(element : T) 这样一个东西。 而且这些 Event 还可以携带数据，它的泛型 就是用来指定这个 Event 携带的数据的类型。 有了可观察序列，我们还需要有一个 Observer（订阅者）来订阅它，这样这个订阅者才能收到 Observable 不时发出的 Event。Event查看 RxSwift 源码可以发现，事件 Event 的定义如下： 12345678910public enum Event&lt;Element&gt; &#123; /// Next element is produced. case next(Element) /// Sequence terminated with an error. case error(Swift.Error) /// Sequence completed successfully. case completed&#125; 可以看到 Event 就是一个枚举，也就是说一个 Observable 是可以发出 3 种不同类型的 Event 事件： next：next 事件就是那个可以携带数据 的事件，可以说它就是一个“最正常”的事件。 error：error 事件表示一个错误，它可以携带具体的错误内容，一旦 Observable 发出了 error event，则这个 Observable 就等于终止了，以后它再也不会发出 event 事件了。 completed：completed 事件表示 Observable 发出的事件正常地结束了，跟 error 一样，一旦 Observable 发出了 completed event，则这个 Observable 就等于终止了，以后它再也不会发出 event 事件了Observable 与 Sequence比较(1)、为更好地理解，我们可以把每一个 Observable 的实例想象成于一个 Swift 中的 Sequence： 即一个 Observable（ObservableType）相当于一个序列 Sequence（SequenceType）。 ObservableType.subscribe(_:) 方法其实就相当于 SequenceType.generate()。 (2)、但它们之间还是有许多区别的： Swift 中的 SequenceType 是同步的循环，而 Observable 是异步的。 Observable 对象会在有任何 Event 时候，自动将 Event 作为一个参数通过 ObservableType.subscribe(_:) 发出，并不需要使用 next 方法。创建 Observable 序列just() 方法（1）该方法通过传入一个默认值来初始化。（2）下面样例我们显式地标注出了 observable 的类型为 Observable，即指定了这个 Observable 所发出的事件携带的数据类型必须是 Int 类型的。 1let observable = Observable&lt;Int&gt;.just(5) of() 方法（1）该方法可以接受可变数量的参数（必需要是同类型的）（2）下面样例中我没有显式地声明出 Observable 的泛型类型，Swift 也会自动推断类型。1let observable = Observable.of("A", "B", "C") from() 方法（1）该方法需要一个数组参数。（2）下面样例中数据里的元素就会被当做这个 Observable 所发出 event 携带的数据内容，最终效果同上面饿 of() 样例是一样的。1let observable = Observable.from(["A", "B", "C"]) empty() 方法该方法创建一个空内容的 Observable 序列。1let observable = Observable&lt;Int&gt;.empty() never() 方法该方法创建一个永远不会发出 Event（也不会终止）的 Observable 序列。1let observable = Observable&lt;Int&gt;.never() error() 方法该方法创建一个不做任何操作，而是直接发送一个错误的 Observable 序列。123456enum MyError: Error &#123; case A case B&#125; let observable = Observable&lt;Int&gt;.error(MyError.A) range() 方法（1）该方法通过指定起始和结束数值，创建一个以这个范围内所有值作为初始值的 Observable 序列。（2）下面样例中，两种方法创建的 Observable 序列都是一样的。12345//使用range()let observable = Observable.range(start: 1, count: 5) //使用of()let observable = Observable.of(1, 2, 3 ,4 ,5) repeatElement() 方法该方法创建一个可以无限发出给定元素的 Event 的 Observable 序列（永不终止）。1let observable = Observable.repeatElement(1) generate() 方法（1）该方法创建一个只有当提供的所有的判断条件都为 true 的时候，才会给出动作的 Observable 序列。（2）下面样例中，两种方法创建的 Observable 序列都是一样的。123456789//使用generate()方法let observable = Observable.generate( initialState: 0, condition: &#123; $0 &lt;= 10 &#125;, iterate: &#123; $0 + 2 &#125;) //使用of()方法let observable = Observable.of(0 , 2 ,4 ,6 ,8 ,10) create() 方法（1）该方法接受一个 block 形式的参数，任务是对每一个过来的订阅进行处理。（2）下面是一个简单的样例。为方便演示，这里增加了订阅相关代码（关于订阅我之后会详细介绍的）。123456789101112131415//这个block有一个回调参数observer就是订阅这个Observable对象的订阅者//当一个订阅者订阅这个Observable对象的时候，就会将订阅者作为参数传入这个block来执行一些内容let observable = Observable&lt;String&gt;.create&#123;observer in //对订阅者发出了.next事件，且携带了一个数据"hangge.com" observer.onNext("hangge.com") //对订阅者发出了.completed事件 observer.onCompleted() //因为一个订阅行为会有一个Disposable类型的返回值，所以在结尾一定要returen一个Disposable return Disposables.create()&#125; //订阅测试observable.subscribe &#123; print($0)&#125; deferred() 方法该个方法相当于是创建一个 Observable 工厂，通过传入一个 block 来执行延迟 Observable 序列创建的行为，而这个 block 里就是真正的实例化序列对象的地方。1234567891011121314151617181920212223242526//用于标记是奇数、还是偶数var isOdd = true //使用deferred()方法延迟Observable序列的初始化，通过传入的block来实现Observable序列的初始化并且返回。let factory : Observable&lt;Int&gt; = Observable.deferred &#123; //让每次执行这个block时候都会让奇、偶数进行交替 isOdd = !isOdd //根据isOdd参数，决定创建并返回的是奇数Observable、还是偶数Observable if isOdd &#123; return Observable.of(1, 3, 5 ,7) &#125;else &#123; return Observable.of(2, 4, 6, 8) &#125;&#125; //第1次订阅测试factory.subscribe &#123; event in print("\(isOdd)", event)&#125; //第2次订阅测试factory.subscribe &#123; event in print("\(isOdd)", event)&#125; interval() 方法（1）这个方法创建的 Observable 序列每隔一段设定的时间，会发出一个索引数的元素。而且它会一直发送下去。（2）下面方法让其每 1 秒发送一次，并且是在主线程（MainScheduler）发送。1234let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)observable.subscribe &#123; event in print(event)&#125; timer() 方法（1）这个方法有两种用法，一种是创建的 Observable 序列在经过设定的一段时间后，产生唯一的一个元素。12345//5秒种后发出唯一的一个元素0let observable = Observable&lt;Int&gt;.timer(5, scheduler: MainScheduler.instance)observable.subscribe &#123; event in print(event)&#125; （2）另一种是创建的 Observable 序列在经过设定的一段时间后，每隔一段时间产生一个元素。12345//延时5秒种后，每隔1秒钟发出一个元素let observable = Observable&lt;Int&gt;.timer(5, period: 1, scheduler: MainScheduler.instance)observable.subscribe &#123; event in print(event)&#125; 订阅 Observable第一种用法：（1）我们使用 subscribe() 订阅了一个 Observable 对象，该方法的 block 的回调参数就是被发出的 event 事件，我们将其直接打印出来。12345let observable = Observable.of("A", "B", "C") observable.subscribe &#123; event in print(event)&#125; 输入结果可以看出 初始化 Observable 序列时设置的默认值都按顺序通过 .next 事件发送出来。 当 Observable 序列的初始数据都发送完毕，它还会自动发一个 .completed 事件出来。 （2）如果想要获取到这个事件里的数据，可以通过 event.element 得到。12345let observable = Observable.of("A", "B", "C") observable.subscribe &#123; event in print(event.element)&#125; 第二种用法：（1）RxSwift 还提供了另一个 subscribe 方法，它可以把 event 进行分类： 通过不同的 block 回调处理不同类型的 event。（其中 onDisposed 表示订阅行为被 dispose 后的回调，这个我后面会说） 同时会把 event 携带的数据直接解包出来作为参数，方便我们使用。1234567891011let observable = Observable.of("A", "B", "C") observable.subscribe(onNext: &#123; element in print(element)&#125;, onError: &#123; error in print(error)&#125;, onCompleted: &#123; print("completed")&#125;, onDisposed: &#123; print("disposed")&#125;) 2）subscribe() 方法的 onNext、onError、onCompleted 和 onDisposed 这四个回调 block 参数都是有默认值的，即它们都是可选的。所以我们也可以只处理 onNext 而不管其他的情况。12345let observable = Observable.of("A", "B", "C") observable.subscribe(onNext: &#123; element in print(element)&#125;) 监听事件的生命周期1、 doOn 介绍（1）我们可以使用 doOn 方法来监听事件的生命周期，它会在每一次事件发送前被调用。（2）同时它和 subscribe 一样，可以通过不同的 block 回调处理不同类型的 event。比如： do(onNext:) 方法就是在 subscribe(onNext:) 前调用 而 do(onCompleted:) 方法则会在 subscribe(onCompleted:) 前面调用。 使用样例123456789101112131415161718192021let observable = Observable.of("A", "B", "C") observable .do(onNext: &#123; element in print("Intercepted Next：", element) &#125;, onError: &#123; error in print("Intercepted Error：", error) &#125;, onCompleted: &#123; print("Intercepted Completed") &#125;, onDispose: &#123; print("Intercepted Disposed") &#125;) .subscribe(onNext: &#123; element in print(element) &#125;, onError: &#123; error in print(error) &#125;, onCompleted: &#123; print("completed") &#125;, onDisposed: &#123; print("disposed") &#125;) Observable 的销毁（Dispose）1、Observable 从创建到终结流程（1）一个 Observable 序列被创建出来后它不会马上就开始被激活从而发出 Event，而是要等到它被某个人订阅了才会激活它。（2）而 Observable 序列激活之后要一直等到它发出了 .error 或者 .completed 的 event 后，它才被终结。 2、dispose() 方法（1）使用该方法我们可以手动取消一个订阅行为。（2）如果我们觉得这个订阅结束了不再需要了，就可以调用 dispose() 方法把这个订阅给销毁掉，防止内存泄漏。（2）当一个订阅行为被 dispose 了，那么之后 observable 如果再发出 event，这个已经 dispose 的订阅就收不到消息了。下面是一个简单的使用样例。123456789let observable = Observable.of("A", "B", "C") //使用subscription常量存储这个订阅方法let subscription = observable.subscribe &#123; event in print(event)&#125; //调用这个订阅的dispose()方法subscription.dispose() 3、DisposeBag除了 dispose() 方法之外，我们更经常用到的是一个叫 DisposeBag 的对象来管理多个订阅行为的销毁：我们可以把一个 DisposeBag 对象看成一个垃圾袋，把用过的订阅行为都放进去。而这个 DisposeBag 就会在自己快要 dealloc 的时候，对它里面的所有订阅行为都调用 dispose() 方法。下面是一个简单的使用样例。12345678910111213let disposeBag = DisposeBag() //第1个Observable，及其订阅let observable1 = Observable.of("A", "B", "C")observable1.subscribe &#123; event in print(event)&#125;.disposed(by: disposeBag) //第2个Observable，及其订阅let observable2 = Observable.of(1, 2, 3)observable2.subscribe &#123; event in print(event)&#125;.disposed(by: disposeBag) 观察者（Observer）介绍观察者（Observer）的作用就是监听事件，然后对这个事件做出响应。或者说任何响应事件的行为都是观察者。比如： 当我们点击按钮，弹出一个提示框。那么这个“弹出一个提示框”就是观察者 Observer 当我们请求一个远程的 json 数据后，将其打印出来。那么这个“打印 json 数据”就是观察者 Observer 直接在 subscribe、bind 方法中创建观察者1. 在 subscribe 方法中创建（1）创建观察者最直接的方法就是在 Observable 的 subscribe 方法后面描述当事件发生时，需要如何做出响应。（2）比如下面的样例，观察者就是由后面的 onNext，onError，onCompleted 这些闭包构建出来的。123456789let observable = Observable.of("A", "B", "C") observable.subscribe(onNext: &#123; element in print(element)&#125;, onError: &#123; error in print(error)&#125;, onCompleted: &#123; print("completed")&#125;) 2. 在 bind 方法中创建下面代码我们创建一个定时生成索引数的 Observable 序列，并将索引数不断显示在 label 标签上：123456789101112131415161718192021222324import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; @IBOutlet weak var label: UILabel! let disposeBag = DisposeBag() override func viewDidLoad() &#123; //Observable序列（每隔1秒钟发出一个索引数） let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) observable .map &#123; "当前索引数：\($0 )"&#125; .bind &#123; [weak self](text) in //收到发出的索引数后显示到label上 self?.label.text = text &#125; .disposed(by: disposeBag) &#125;&#125; 使用 AnyObserver 创建观察者AnyObserver 可以用来描叙任意一种观察者。 1、配合 subscribe 方法使用比如上面第一个样例我们可以改成如下代码：1234567891011121314//观察者let observer: AnyObserver&lt;String&gt; = AnyObserver &#123; (event) in switch event &#123; case .next(let data): print(data) case .error(let error): print(error) case .completed: print("completed") &#125;&#125; let observable = Observable.of("A", "B", "C")observable.subscribe(observer) 2、配合 bindTo 方法使用也可配合 Observable 的数据绑定方法（bindTo）使用。比如上面的第二个样例我可以改成如下代码：12345678910111213141516171819202122232425262728293031import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; @IBOutlet weak var label: UILabel! let disposeBag = DisposeBag() override func viewDidLoad() &#123; //观察者 let observer: AnyObserver&lt;String&gt; = AnyObserver &#123; [weak self] (event) in switch event &#123; case .next(let text): //收到发出的索引数后显示到label上 self?.label.text = text default: break &#125; &#125; //Observable序列（每隔1秒钟发出一个索引数） let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) observable .map &#123; "当前索引数：\($0 )"&#125; .bind(to: observer) .disposed(by: disposeBag) &#125;&#125; 使用 Binder 创建观察者1、基本介绍（1）相较于 AnyObserver 的大而全，Binder 更专注于特定的场景。Binder 主要有以下两个特征： 不会处理错误事件 确保绑定都是在给定 Scheduler 上执行（默认 MainScheduler） （2）一旦产生错误事件，在调试环境下将执行 fatalError，在发布环境下将打印错误信息。 使用样例（1）在上面序列数显示样例中，label 标签的文字显示就是一个典型的 UI 观察者。它在响应事件时，只会处理 next 事件，而且更新 UI 的操作需要在主线程上执行。那么这种情况下更好的方案就是使用 Binder。（2）上面的样例我们改用 Binder 会简单许多：1234567891011121314151617181920212223242526import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; @IBOutlet weak var label: UILabel! let disposeBag = DisposeBag() override func viewDidLoad() &#123; //观察者 let observer: Binder&lt;String&gt; = Binder(label) &#123; (view, text) in //收到发出的索引数后显示到label上 view.text = text &#125; //Observable序列（每隔1秒钟发出一个索引数） let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) observable .map &#123; "当前索引数：\($0 )"&#125; .bind(to: observer) .disposed(by: disposeBag) &#125;&#125; 附：Binder 在 RxCocoa 中的应用（1）其实 RxCocoa 在对许多 UI 控件进行扩展时，就利用 Binder 将控件属性变成观查者，比如 UIControl+Rx.swift 中的 isEnabled 属性便是一个 observer ：123456789101112import RxSwiftimport UIKit extension Reactive where Base: UIControl &#123; /// Bindable sink for `enabled` property. public var isEnabled: Binder&lt;Bool&gt; &#123; return Binder(self.base) &#123; control, value in control.isEnabled = value &#125; &#125;&#125; （2）因此我们可以将序列直接绑定到它上面。比如下面样例，button 会在可用、不可用这两种状态间交替变换（每隔一秒）。123456//Observable序列（每隔1秒钟发出一个索引数）let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)observable .map &#123; $0 % 2 == 0 &#125; .bind(to: button.rx.isEnabled) .disposed(by: disposeBag) 自定义可绑定属性有时我们想让 UI 控件创建出来后默认就有一些观察者，而不必每次都为它们单独去创建观察者。比如我们想要让所有的 UIlabel 都有个 fontSize 可绑定属性，它会根据事件值自动改变标签的字体大小。 方式一：通过对 UI 类进行扩展这里我们通过对 UILabel 进行扩展，增加了一个 fontSize 可绑定属性。12345678910111213141516171819202122232425262728import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; @IBOutlet weak var label: UILabel! let disposeBag = DisposeBag() override func viewDidLoad() &#123; //Observable序列（每隔0.5秒钟发出一个索引数） let observable = Observable&lt;Int&gt;.interval(0.5, scheduler: MainScheduler.instance) observable .map &#123; CGFloat($0) &#125; .bind(to: label.fontSize) //根据索引数不断变放大字体 .disposed(by: disposeBag) &#125;&#125; extension UILabel &#123; public var fontSize: Binder&lt;CGFloat&gt; &#123; return Binder(self) &#123; label, fontSize in label.font = UIFont.systemFont(ofSize: fontSize) &#125; &#125;&#125; 方式二：通过对 Reactive 类进行扩展既然使用了 RxSwift，那么更规范的写法应该是对 Reactive 进行扩展。这里同样是给 UILabel 增加了一个 fontSize 可绑定属性。（注意：这种方式下，我们绑定属性时要写成 label.rx.fontSize）12345678910111213141516171819202122232425262728import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; @IBOutlet weak var label: UILabel! let disposeBag = DisposeBag() override func viewDidLoad() &#123; //Observable序列（每隔0.5秒钟发出一个索引数） let observable = Observable&lt;Int&gt;.interval(0.5, scheduler: MainScheduler.instance) observable .map &#123; CGFloat($0) &#125; .bind(to: label.rx.fontSize) //根据索引数不断变放大字体 .disposed(by: disposeBag) &#125;&#125; extension Reactive where Base: UILabel &#123; public var fontSize: Binder&lt;CGFloat&gt; &#123; return Binder(self.base) &#123; label, fontSize in label.font = UIFont.systemFont(ofSize: fontSize) &#125; &#125;&#125; RxSwift 自带的可绑定属性（UI 观察者）（1）其实 RxSwift 已经为我们提供许多常用的可绑定属性。比如 UILabel 就有 text 和 attributedText 这两个可绑定属性。1234567891011121314151617181920import RxSwiftimport UIKit extension Reactive where Base: UILabel &#123; /// Bindable sink for `text` property. public var text: Binder&lt;String?&gt; &#123; return Binder(self.base) &#123; label, text in label.text = text &#125; &#125; /// Bindable sink for `attributedText` property. public var attributedText: Binder&lt;NSAttributedString?&gt; &#123; return Binder(self.base) &#123; label, text in label.attributedText = text &#125; &#125; &#125; （2）那么上文那个定时显示索引数的样例，我们其实不需要自定义 UI 观察者，直接使用 RxSwift 提供的绑定属性即可。1234567891011121314151617181920import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; @IBOutlet weak var label: UILabel! let disposeBag = DisposeBag() override func viewDidLoad() &#123; //Observable序列（每隔1秒钟发出一个索引数） let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance) observable .map &#123; "当前索引数：\($0 )"&#125; .bind(to: label.rx.text) //收到发出的索引数后显示到label上 .disposed(by: disposeBag) &#125;&#125; Subjects 介绍Subjects 基本介绍（1）Subjects 既是订阅者，也是 Observable： 说它是订阅者，是因为它能够动态地接收新的值。 说它又是一个 Observable，是因为当 Subjects 有了新的值之后，就会通过 Event 将新值发出给他的所有订阅者。 （2）一共有四种 Subjects，分别为：PublishSubject、BehaviorSubject、ReplaySubject、Variable。他们之间既有各自的特点，也有相同之处： 首先他们都是 Observable，他们的订阅者都能收到他们发出的新的 Event。 直到 Subject 发出 .complete 或者 .error 的 Event 后，该 Subject 便终结了，同时它也就不会再发出 .next 事件。 对于那些在 Subject 终结后再订阅他的订阅者，也能收到 subject 发出的一条 .complete 或 .error 的 event，告诉这个新的订阅者它已经终结了。 他们之间最大的区别只是在于：当一个新的订阅者刚订阅它的时候，能不能收到 Subject 以前发出过的旧 Event，如果能的话又能收到多少个。 （3）Subject 常用的几个方法： onNext(:)：是 on(.next(:)) 的简便写法。该方法相当于 subject 接收到一个 .next 事件。 onError(:)：是 on(.error(:)) 的简便写法。该方法相当于 subject 接收到一个 .error 事件。 onCompleted()：是 on(.completed) 的简便写法。该方法相当于 subject 接收到一个 .completed 事件。 PublishSubject（1）基本介绍 PublishSubject 是最普通的 Subject，它不需要初始值就能创建。 PublishSubject 的订阅者从他们开始订阅的时间点起，可以收到订阅后 Subject 发出的新 Event，而不会收到他们在订阅前已发出的 Event。（2）时序图 最上面一条是 BehaviorSubject。-下面两条分别表示两个新的订阅，它们订阅的时间点不同，可以发现 BehaviorSubject 的订阅者一开始就能收到 BehaviorSubjects 之前发出的一个 Event。（3）使用样例1234567891011121314151617181920let disposeBag = DisposeBag() //创建一个BehaviorSubjectlet subject = BehaviorSubject(value: "111") //第1次订阅subjectsubject.subscribe &#123; event in print("第1次订阅：", event)&#125;.disposed(by: disposeBag) //发送next事件subject.onNext("222") //发送error事件subject.onError(NSError(domain: "local", code: 0, userInfo: nil)) //第2次订阅subjectsubject.subscribe &#123; event in print("第2次订阅：", event)&#125;.disposed(by: disposeBag) ReplaySubject（1）基本介绍 ReplaySubject 在创建时候需要设置一个 bufferSize，表示它对于它发送过的 event 的缓存个数。 比如一个 ReplaySubject 的 bufferSize 设置为 2，它发出了 3 个 .next 的 event，那么它会将后两个（最近的两个）event 给缓存起来。此时如果有一个 subscriber 订阅了这个 ReplaySubject，那么这个 subscriber 就会立即收到前面缓存的两个 .next 的 event。 如果一个 subscriber 订阅已经结束的 ReplaySubject，除了会收到缓存的 .next 的 event 外，还会收到那个终结的 .error 或者 .complete 的 event。 （2）时序图 最上面一条是 ReplaySubject（bufferSize 设为为 2）。 下面两条分别表示两个新的订阅，它们订阅的时间点不同。可以发现 ReplaySubject 的订阅者一开始就能收到 ReplaySubject 之前发出的两个 Event（如果有的话）。（3）使用样例123456789101112131415161718192021222324252627282930let disposeBag = DisposeBag() //创建一个bufferSize为2的ReplaySubjectlet subject = ReplaySubject&lt;String&gt;.create(bufferSize: 2) //连续发送3个next事件subject.onNext("111")subject.onNext("222")subject.onNext("333") //第1次订阅subjectsubject.subscribe &#123; event in print("第1次订阅：", event)&#125;.disposed(by: disposeBag) //再发送1个next事件subject.onNext("444") //第2次订阅subjectsubject.subscribe &#123; event in print("第2次订阅：", event)&#125;.disposed(by: disposeBag) //让subject结束subject.onCompleted() //第3次订阅subjectsubject.subscribe &#123; event in print("第3次订阅：", event)&#125;.disposed(by: disposeBag) Variable（注意：由于 Variable 在之后版本中将被废弃，建议使用 Varible 的地方都改用下面介绍的 BehaviorRelay 作为替代。）（1）基本介绍 Variable 其实就是对 BehaviorSubject 的封装，所以它也必须要通过一个默认的初始值进行创建。 Variable 具有 BehaviorSubject 的功能，能够向它的订阅者发出上一个 event 以及之后新创建的 event。 不同的是，Variable 还把会把当前发出的值保存为自己的状态。同时它会在销毁时自动发送 .complete 的 event，不需要也不能手动给 Variables 发送 completed 或者 error 事件来结束它。 简单地说就是 Variable 有一个 value 属性，我们改变这个 value 属性的值就相当于调用一般 Subjects 的 onNext() 方法，而这个最新的 onNext() 的值就被保存在 value 属性里了，直到我们再次修改它。 注意：Variables 本身没有 subscribe() 方法，但是所有 Subjects 都有一个 asObservable() 方法。我们可以使用这个方法返回这个 Variable 的 Observable 类型，拿到这个 Observable 类型我们就能订阅它了。 （2）使用样例12345678910111213141516171819202122232425262728293031323334import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let disposeBag = DisposeBag() //创建一个初始值为111的Variable let variable = Variable("111") //修改value值 variable.value = "222" //第1次订阅 variable.asObservable().subscribe &#123; print("第1次订阅：", $0) &#125;.disposed(by: disposeBag) //修改value值 variable.value = "333" //第2次订阅 variable.asObservable().subscribe &#123; print("第2次订阅：", $0) &#125;.disposed(by: disposeBag) //修改value值 variable.value = "444" &#125;&#125; BehaviorRelay（1）基本介绍 BehaviorRelay 是作为 Variable 的替代者出现的。它的本质其实也是对 BehaviorSubject 的封装，所以它也必须要通过一个默认的初始值进行创建。 BehaviorRelay 具有 BehaviorSubject 的功能，能够向它的订阅者发出上一个 event 以及之后新创建的 event。 与 BehaviorSubject 不同的是，不需要也不能手动给 BehaviorReply 发送 completed 或者 error 事件来结束它（BehaviorRelay 会在销毁时也不会自动发送 .complete 的 event）。 BehaviorRelay 有一个 value 属性，我们通过这个属性可以获取最新值。而通过它的 accept() 方法可以对值进行修改。 （2）上面的 Variable 样例我们可以改用成 BehaviorRelay，代码如下：12345678910111213141516171819202122232425262728293031323334import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let disposeBag = DisposeBag() //创建一个初始值为111的BehaviorRelay let subject = BehaviorRelay&lt;String&gt;(value: "111") //修改value值 subject.accept("222") //第1次订阅 subject.asObservable().subscribe &#123; print("第1次订阅：", $0) &#125;.disposed(by: disposeBag) //修改value值 subject.accept("333") //第2次订阅 subject.asObservable().subscribe &#123; print("第2次订阅：", $0) &#125;.disposed(by: disposeBag) //修改value值 subject.accept("444") &#125;&#125; （3）如果想将新值合并到原值上，可以通过 accept() 方法与 value 属性配合来实现。（这个常用在表格上拉加载功能上，BehaviorRelay 用来保存所有加载到的数据）12345678910111213141516171819202122232425262728293031323334import UIKitimport RxSwiftimport RxCocoa class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let disposeBag = DisposeBag() //创建一个初始值为包含一个元素的数组的BehaviorRelay let subject = BehaviorRelay&lt;[String]&gt;(value: ["1"]) //修改value值 subject.accept(subject.value + ["2", "3"]) //第1次订阅 subject.asObservable().subscribe &#123; print("第1次订阅：", $0) &#125;.disposed(by: disposeBag) //修改value值 subject.accept(subject.value + ["4", "5"]) //第2次订阅 subject.asObservable().subscribe &#123; print("第2次订阅：", $0) &#125;.disposed(by: disposeBag) //修改value值 subject.accept(subject.value + ["6", "7"]) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CALayer的属性和使用(未完结)]]></title>
    <url>%2F2018%2F11%2F23%2FCALayer%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BD%BF%E7%94%A8(%E6%9C%AA%E5%AE%8C%E7%BB%93)%2F</url>
    <content type="text"><![CDATA[一、CALayer的常用属性 1、@propertyCGPoint position;图层中心点的位置，类似与UIView的center；用来设置CALayer在父层中的位置；以父层的左上角为原点（0，0） 2、 @property CGPoint anchorPoint;称『定位点』、『锚点』，该描述是相对于x、y位置比例而言的默认在图像中心点（0.5、0.5）的位置；决定着CALayer身上的哪个点会再position属性所指的位置，以自己的左上角为原点（0，0）；它的x、y取值范围都是0~1 3、 @property(nullable) CGColorRef backgroundColor图层背景颜色 4、 @property(nullable) CGColorRef borderColor图层边框颜色 5、 @property CGFloat borderWidth图层边框宽度 6、 @property CGRect bounds图层大小 7、 @property(nullable, strong) id contents图层显示内容，例如可以将图片作为图层内容显示 8、 @property CGRect contentsRect图层显示内容的大小和位置 9、 @property CGFloat cornerRadius圆角半径 10、 @property(getter=isDoubleSided) BOOL doubleSided图层背景是否显示，默认是YES 11、 @property CGRect frame图层大小和位置，不支持隐式动画，所以CALyaer中很少使用frame，通常使用bound和position代替 12、 @property(getter=isHidden) BOOL hidden是否隐藏 13、 @property(nullable, strong) CALayer *mask图层蒙版 14、 @property BOOL masksToBounds子图层是否剪切图层边界，默认是NO 15、 @property float opacit;图层透明度，类似与UIView的alpha 16、 @property(nullable) CGColorRef shadowColor阴影颜色 17、 @property CGSize shadowOffset阴影偏移量 18、 @property float shadowOpacity阴影透明度，注意默认为0，如果设置阴影必须设置此属性 19、 @property(nullable) CGPathRef shadowPath阴影形状 20、 @property CGFloat shadowRadius阴影模糊半径 21、 @property(nullable, copy) NSArray 二、CALayer不常用属性 1、 @property CGFloat zPosition图层中心点在z轴中的位置 2、 @property CGFloat anchorPointZ图层在z轴中的锚点； 3、 - (CGAffineTransform)affineTransform 4、- (void)setAffineTransform:(CGAffineTransform)m以上属性为图层形变；该属性值指定一个CGAffineTransform对象，该对象代表对CALayer执行X、Y两个维度（也就是平面）上的旋转、缩放、位移、斜切、镜像等变换矩阵 5、 @property(nullable, readonly) CALayer *superlayer图层的父图层 三、CALayer图层操作 1、 - (void)addSublayer:(CALayer *)layer添加子图层 2、 - (void)removeFromSuperlayer将自己从父图层中移除 3、 - (void)insertSublayer:(CALayer *)layer atIndex:(unsigned)idx在自己子图层数组中的第idx位置添加图层 4、 - (void)insertSublayer:(CALayer )layer below:(nullable CALayer )sibling将图层layer添加在子图层sibling的下面 5、 - (void)insertSublayer:(CALayer )layer above:(nullable CALayer )sibling将图层layer添加在子图层sibling的上面 6、 - (void)replaceSublayer:(CALayer )layer with:(CALayer )layer2将图层layer替换layer2； 四、CALayer动画操作 1、 - (void)addAnimation:(CAAnimation )anim forKey:(nullable NSString )key图层添加某一属性的动画 2、 - (nullable NSArray&lt; NSString &gt; )animationKeys获取所有动画的属性 3、 - (nullable CAAnimation )animationForKey:(NSString )key获取某一属性的动画 4、 - (void)removeAnimationForKey:(NSString *)key移除某一属性动画 5、 - (void)removeAllAnimations移除所有动画 五、CALayer子类其他说明 子类名称 用途 CAEmitterLayer 发射器层，用来控制粒子效果 CAGradientLayer 梯度层，颜色渐变 CAEAGLayer 用OpenGL ES绘制的层 CAReplicationLayer 用来自动复制sublayer CAShapeLayer 绘制立体的贝塞尔曲线 CAScrollLayer 用来管理可滑动的区域 CATextLayer 可以绘制AttributeString CATiledLayer 用来管理一副可以被分割的大图 CATransformLayer 用来渲染3D layer的层次结构 1. CAShapeLayerCAShapeLayer属于QuartzCore框架，继承自CALayer。CAShapeLayer是在坐标系内绘制贝塞尔曲线的，通过绘制贝塞尔曲线，设置shape(形状)的path(路径)，从而绘制各种各样的图形以及不规则图形。因此，使用CAShapeLayer需要与UIBezierPath一起使用。UIBezierPath类允许你在自定义的 View 中绘制和渲染由直线和曲线组成的路径.。你可以在初始化的时候直接为你的UIBezierPath指定一个几何图形。通俗点就是UIBezierPath用来指定绘制图形路径，而CAShapeLayer就是根据路径来绘图的。 属性 1、@property(nullable) CGPathRef path; 呈现的形状的路径 2、@property(nullable) CGColorRef fillColor;填充路径的颜色 3、@property(copy) CAShapeLayerFillRule fillRule; 当在填充颜色的时候则就需要这种填充规则，值有两种，非零和奇偶数，但默认是非零值。 4、@property(nullable) CGColorRef strokeColor;设置描边色，默认无色。 5、@property CGFloat strokeStart; 绘制边线轮廓路径的子区域。该值必须在[0,1]范围，0代表路径的开始，1代表路径的结束。 默认为0 6、@property CGFloat strokeEnd; 默认为1 7、@property CGFloat lineWidth; 线的宽度 默认为1 8、@property CGFloat miterLimit;最大斜接长度。斜接长度指的是在两条线交汇处和外交之间的距离。只有lineJoin属性为kCALineJoinMiter时miterLimit才有效。边角的角度越小，斜接长度就会越大。为了避免斜接长度过长，我们可以使用miterLimit属性。如果斜接长度超过miterLimit的值，边角会以lineJoin的“bevel”即kCALineJoinBevel类型来显示。 9、@property(copy) CAShapeLayerLineCap lineCap; 线端点类型，值有三个类型，分别为kCALineCapButt 、kCALineCapRound 、kCALineCapSquare，默认值为Butt； 10、@property(copy) CAShapeLayerLineJoin lineJoin;lineJoin为线连接类型，其值也有三个类型，分别为kCALineJoinMiter、kCALineJoinRound、kCALineJoinBevel，默认值是Miter。 11、@property CGFloat lineDashPhase;为线型模版的起始位置；lineDashPattern为线性模版，这是一个NSNumber的数组，索引从1开始记，奇数位数值表示实线长度，偶数位数值表示空白长度。注：fillColor与strokeColor都是在有UIBezierPath参数配置的情况下才能发生作用 12、@property(nullable, copy) NSArray *lineDashPattern; 2.CAReplicationLayer属性 1、@property NSInteger instanceCount; 复制subLayer个数，默认为1 2、@property BOOL preservesDepth; 是否将3D例子系统平面化到一个图层（默认值）或者可以在3D空间中混合其他的图层 3、@property CFTimeInterval instanceDelay; 设置复制子层的延迟动画时长 4、@property CATransform3D instanceTransform; 设置复制子层的相对位置 5、@property(nullable) CGColorRef instanceColor; 子层颜色，会和原生子层背景色冲突，因此二者选其一设置 6、@property float instanceRedOffset;设置每个复制图层相对上一个复制图层的红色偏移量 7、@property float instanceRedOffset;设置每个复制图层相对上一个复制图层的绿色偏移量 8、@property float instanceBlueOffset;设置每个复制图层相对上一个复制图层的蓝色偏移量 9、@property float instanceAlphaOffset;设置每个复制图层相对上一个复制图层的透明度偏移量]]></content>
  </entry>
  <entry>
    <title><![CDATA[CAAniamtion的属性和使用]]></title>
    <url>%2F2018%2F11%2F23%2FCAAniamtion%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[CAAnimationCAAnimation是所有动画对象的父类，负责控制动画的持续时间和速度，是个抽象类，不能直接使用，应该使用它具体的子类。 属性 duration：动画的持续时间 repeatCount：动画的重复次数 repeatDuration：动画的重复时间 removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards fillMode：决定当前对象在非active时间段的行为。比如动画开始之前,动画结束之后 beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间 timingFunction：速度控制函数，控制动画运行的节奏 delegate：动画代理 子类1.CAPropertyAnimation是CAAnimation的子类，也是个抽象类，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation。 keyPath 通过指定CALayer的一个属性名称为keyPath(NSString类型)，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@”position”为keyPath，就修改CALayer的position属性的值，以达到平移的动画效果。 2.CABasicAnimation fromValue：keyPath相应属性的初始值。 toValue：keyPath相应属性的结束值。 随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue。 如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。比如，CALayer的position初始值为(0,0)，CABasicAnimation的fromValue为(10,10)，toValue为(100,100)，虽然动画执行完毕后图层保持在(100,100)这个位置，实质上图层的position还是为(0,0)。 3.CAKeyframeAnimationCApropertyAnimation的子类，跟CABasicAnimation的区别是：CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray保存这些数值。 values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧。 path：可以设置一个CGPathRef\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略。 keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的。 CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation。 4.CAAnimationGroupCAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行。 animations：用来保存一组动画对象的NSArray。 默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间。 5.CATransitionCAAnimation的子类，用于做转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。iOS比Mac OS X的转场动画效果少一点。UINavigationController就是通过CATransition实现了将控制器的视图推入屏幕的动画效果。 type：动画过渡类型。 subtype：动画过渡方向。 startProgress：动画起点(在整体动画的百分比)。 endProgress：动画终点(在整体动画的百分比)。]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS自定义控件：提醒条]]></title>
    <url>%2F2018%2F11%2F22%2FiOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%9A%E6%8F%90%E9%86%92%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[简单的提醒条，代码比较简单，使用容易，代码中目前提供了三种显示的颜色，默认显示文本内容为一行文字，默认高度为20，可以根据自己需求自定义样式。代码同时支持Objective-C和Swift，使用方式有点点差别，详情看代码。 接口文件123456789101112131415161718192021222324252627282930313233343536#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGINtypedef NS_ENUM(NSInteger, RemindBarStyle) &#123; RemindBarStyleInfo, // 提醒 ❇️ RemindBarStyleWarn, // 警告 ⚠️ RemindBarStyleError // 错误 ❌&#125;;typedef NS_ENUM(NSInteger, RemindBarPosition) &#123; RemindBarPositionStatusBar, // 状态栏下面 RemindBarPositionNavigationBar, // 导航栏下面&#125;;@interface LZRemindBar : UIView/** 配置显示样式 @param style 样式 @param position 位置 @param text 内容 @return return value description */+ (LZRemindBar *)configurationWithStyle:(RemindBarStyle)style showPosition:(RemindBarPosition)position contentText:(NSString *)text;/** 显示 并设置显示时间 @param interval 显示时间 */- (void)showBarAfterTimeInterval:(NSTimeInterval)interval;@endNS_ASSUME_NONNULL_END 实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#import "LZRemindBar.h"#define bar_IsPhoneX UIApplication.sharedApplication.statusBarFrame.size.height != 20#define bar_topInterval bar_IsPhoneX ? UIApplication.sharedApplication.statusBarFrame.size.height : 0@interface LZRemindBar ()@property (nonatomic, strong) UILabel *contentLabel; //*! 文字Label@property (nonatomic, assign) RemindBarPosition position; //*! 显示位置@property (nonatomic, assign) BOOL isShowing; //*! 是否正在显示@end@implementation LZRemindBar+ (instancetype)remind &#123; static dispatch_once_t onceToken; static LZRemindBar *remind; dispatch_once(&amp;onceToken, ^&#123; remind = [[LZRemindBar alloc] init]; &#125;); return remind;&#125;+ (LZRemindBar *)configurationWithStyle:(RemindBarStyle)style showPosition:(RemindBarPosition)position contentText:(NSString *)text &#123; if ([LZRemindBar remind].isShowing) &#123; return [LZRemindBar remind]; &#125; [LZRemindBar remind].contentLabel = (&#123; UILabel *label = [[UILabel alloc] init]; label.backgroundColor = UIColor.clearColor; label.numberOfLines = 1; label.textAlignment = NSTextAlignmentCenter; label.font = [UIFont systemFontOfSize:13]; label.textColor = UIColor.whiteColor; [[LZRemindBar remind] addSubview:label]; label.translatesAutoresizingMaskIntoConstraints = false; [[label.leadingAnchor constraintEqualToAnchor:[LZRemindBar remind].leadingAnchor] setActive:true]; [[label.trailingAnchor constraintEqualToAnchor:[LZRemindBar remind].trailingAnchor] setActive:true]; [[label.topAnchor constraintEqualToAnchor:[LZRemindBar remind].topAnchor] setActive:true]; [[label.bottomAnchor constraintEqualToAnchor:[LZRemindBar remind].bottomAnchor] setActive:true]; label.text = text; label; &#125;); [LZRemindBar remind].isShowing = true; [LZRemindBar remind].position = position; switch (style) &#123; case RemindBarStyleInfo: [LZRemindBar remind].backgroundColor = [UIColor colorWithRed:0 green:166.0/255 blue:124.0/255 alpha:1]; break; case RemindBarStyleWarn: [LZRemindBar remind].backgroundColor = UIColor.orangeColor; break; case RemindBarStyleError: [LZRemindBar remind].backgroundColor = UIColor.redColor; break; default: break; &#125; if (position == RemindBarPositionStatusBar) &#123; [[LZRemindBar remind] setupShowStatusBarBottomWithStutus:true]; &#125; else &#123; [[LZRemindBar remind] setupShowNavigationBarBottomWithStutus:true]; &#125; return [LZRemindBar remind];&#125;- (void)setupShowStatusBarBottomWithStutus:(BOOL)show &#123; if (show) &#123; UIApplication.sharedApplication.delegate.window.windowLevel = bar_IsPhoneX ? UIWindowLevelNormal : UIWindowLevelAlert; self.frame = CGRectMake(0, bar_topInterval, UIScreen.mainScreen.bounds.size.width, 0); [UIView animateWithDuration:0.5 animations:^&#123; self.frame = CGRectMake(0, bar_topInterval, UIScreen.mainScreen.bounds.size.width, 20); &#125;]; &#125; else &#123; [UIView animateWithDuration:0.5 animations:^&#123; self.frame = CGRectMake(0, bar_topInterval, UIScreen.mainScreen.bounds.size.width, 0); &#125; completion:^(BOOL finished) &#123; UIApplication.sharedApplication.delegate.window.windowLevel = UIWindowLevelNormal; [self dismissBar]; &#125;]; &#125;&#125;- (void)setupShowNavigationBarBottomWithStutus:(BOOL)show &#123; if (show) &#123; self.frame = CGRectMake(0, UIApplication.sharedApplication.statusBarFrame.size.height + 44, UIScreen.mainScreen.bounds.size.width, 0); [UIView animateWithDuration:0.5 animations:^&#123; self.frame = CGRectMake(0, UIApplication.sharedApplication.statusBarFrame.size.height + 44, UIScreen.mainScreen.bounds.size.width, 20); &#125;]; &#125; else &#123; [UIView animateWithDuration:0.5 animations:^&#123; self.frame = CGRectMake(0, UIApplication.sharedApplication.statusBarFrame.size.height + 44, UIScreen.mainScreen.bounds.size.width, 0); &#125; completion:^(BOOL finished) &#123; [self dismissBar]; &#125;]; &#125;&#125;- (void)showBarAfterTimeInterval:(NSTimeInterval)interval &#123; [UIApplication.sharedApplication.delegate.window addSubview:self]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(interval * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; if (self.position == RemindBarPositionStatusBar) &#123; [self setupShowStatusBarBottomWithStutus:false]; &#125; else &#123; [self setupShowNavigationBarBottomWithStutus:false]; &#125; &#125;);&#125;- (void)dismissBar &#123; self.isShowing = false; [self.contentLabel removeFromSuperview]; [self removeFromSuperview];&#125;@end 使用方法123456789// 参数RemindBarStyle： 显示样式// 参数RemindBarPosition: 显示位置 // 参数contentText: 显示文字内容 // interval：显示时间// Objc[[LZRemindBar configurationWithStyle:RemindBarStyleInfo showPosition:RemindBarPositionStatusBar contentText:@"这是一个提示"] showBarAfterTimeInterval:1.2];// SwiftLZRemindBar.configuration(with: .info, show: .statusBar, contentText: "提示文字").show(afterTimeInterval: 1.2) 效果图]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS自定义控件：自定义Alter弹窗]]></title>
    <url>%2F2018%2F11%2F21%2FiOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89Alter%E5%BC%B9%E7%AA%97%2F</url>
    <content type="text"><![CDATA[在下小白一个，准备写写和自己开发息息相关的控件，希望大家批评指正。这是第一个常用的底部弹窗，使用了最简单的分装方式。 1、头文件里面声明了一个代理和初始化方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@class LZAlterView;@protocol LZAlterViewDelegate &lt;NSObject&gt;- (void)alterView:(LZAlterView *)alterView didSelectedAtIndex:(NSInteger)index;@end@interface LZAlterView : UIView+ (instancetype)alter;/** 显示样式一 @param mainTitle 主标题 @param subTitle 副标题 @param actionTitleArray 事件按钮数组 @param cancelTitle 取消按钮 @return return value description */- (LZAlterView *)configureWithMainTitle:(NSString *)mainTitle subTitle:(NSString *)subTitle actionTitleArray:(NSArray&lt;NSString *&gt; *)actionTitleArray cancelActionTitle:(NSString *)cancelTitle;/** 显示样式二 @param mainTitle 主标题 @param subTitle 副标题 @param actionTitleArray 事件按钮组数 @return return value description */- (LZAlterView *)configureWithMainTitle:(NSString *)mainTitle subTitle:(NSString *)subTitle actionTitleArray:(NSArray&lt;NSString *&gt; *)actionTitleArray;/** 显示样式三 @param actionTitleArray 事件按钮数组 @param cancelTitle 取消按钮 @return return value description */- (LZAlterView *)configureWithActionTitleArray:(NSArray&lt;NSString *&gt; *)actionTitleArray cancelActionTitle:(NSString *)cancelTitle;/** 显示样式四 @param actionTitleArray 事件按钮数组 @return return value description */- (LZAlterView *)configureWithActionTitleArray:(NSArray&lt;NSString *&gt; *)actionTitleArray;/** 设置代理 @param delegate 代理 @return return value description */- (LZAlterView *)setupDelegate:(id&lt;LZAlterViewDelegate&gt;)delegate;- (void)showAlter;@endNS_ASSUME_NONNULL_END 2、实现文件里面进行页面的绘制、数据处理和事件处理。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#import "LZAlterView.h"#define alter_ScreenWidth UIScreen.mainScreen.bounds.size.width#define alter_ScreenHeight UIScreen.mainScreen.bounds.size.height#define alter_actionHeight 45 * alter_ScreenWidth/375.0#define alter_cancelSpece 5 * alter_ScreenWidth/375.0#define alter_mainTitleHeight alter_actionHeight + alter_cancelSpece#define alter_FontSize(s) [UIFont systemFontOfSize:s * alter_ScreenWidth/375.0]@interface LZAlterView ()@property (nonatomic) CGRect conterViewRect;@property (nonatomic, strong) UIView *contanerView;@property (nonatomic, weak) id &lt;LZAlterViewDelegate&gt; delegate;@end@implementation LZAlterView+ (instancetype)alter &#123; static dispatch_once_t onceToken; static LZAlterView *alter; dispatch_once(&amp;onceToken, ^&#123; alter = [[LZAlterView alloc] init]; &#125;); return alter;&#125;- (instancetype)init &#123; self = [super init]; if (self) &#123; UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapGestureRecognizer:)]; [self addGestureRecognizer:tap]; &#125; return self;&#125;#pragma mark - Configuration method/** 代理 */- (LZAlterView *)setupDelegate:(id&lt;LZAlterViewDelegate&gt;)delegate &#123; self.delegate = delegate; return self;&#125;/** Set title, subtitle, events and cancel */- (LZAlterView *)configureWithMainTitle:(NSString *)mainTitle subTitle:(NSString *)subTitle actionTitleArray:(NSArray&lt;NSString *&gt; *)actionTitleArray cancelActionTitle:(NSString *)cancelTitle &#123; CGFloat width = alter_actionHeight * (actionTitleArray.count + 1) + alter_cancelSpece + alter_mainTitleHeight; self.contanerView.frame = CGRectMake(0, [self safeScreenHeight] - width, alter_ScreenWidth, width); [self addSubview:self.contanerView]; UILabel *titleLabel = [self setupMainTitle:mainTitle subTitle:subTitle]; titleLabel.frame = CGRectMake(0, 0, alter_ScreenWidth, alter_mainTitleHeight); [self.contanerView addSubview:titleLabel]; UIButton *cancelButton = [self cancelButtonWithTitle:cancelTitle]; cancelButton.frame = CGRectMake(0, self.contanerView.frame.size.height - alter_actionHeight, alter_ScreenWidth, alter_actionHeight); [self.contanerView addSubview:cancelButton]; for (NSString *name in actionTitleArray) &#123; UIButton *button = [self setupActionWithTitle:name]; NSInteger index = [actionTitleArray indexOfObject:name]; button.tag = 1000 + index; button.frame = CGRectMake(0, titleLabel.frame.size.height + 0.5 + alter_actionHeight * index, alter_ScreenWidth, alter_actionHeight - 0.5); [self.contanerView addSubview:button]; &#125; self.conterViewRect = self.contanerView.frame; return self;&#125;/** Set title, subtitle and events */- (LZAlterView *)configureWithMainTitle:(NSString *)mainTitle subTitle:(NSString *)subTitle actionTitleArray:(NSArray&lt;NSString *&gt; *)actionTitleArray &#123; CGFloat width = alter_actionHeight * actionTitleArray.count + alter_mainTitleHeight; self.contanerView.frame = CGRectMake(0, [self safeScreenHeight] - width, alter_ScreenWidth, width); [self addSubview:self.contanerView]; UILabel *titleLabel = [self setupMainTitle:mainTitle subTitle:subTitle]; titleLabel.frame = CGRectMake(0, 0, alter_ScreenWidth, alter_mainTitleHeight); [self.contanerView addSubview:titleLabel]; for (NSString *name in actionTitleArray) &#123; UIButton *button = [self setupActionWithTitle:name]; NSInteger index = [actionTitleArray indexOfObject:name]; button.tag = 1000 + index; button.frame = CGRectMake(0, titleLabel.frame.size.height + 0.5 + alter_actionHeight * index, alter_ScreenWidth, alter_actionHeight - 0.5); [self.contanerView addSubview:button]; &#125; self.conterViewRect = self.contanerView.frame; return self;&#125;/** Set events and cancel */- (LZAlterView *)configureWithActionTitleArray:(NSArray&lt;NSString *&gt; *)actionTitleArray cancelActionTitle:(NSString *)cancelTitle &#123; CGFloat width = alter_actionHeight * (actionTitleArray.count + 1) + alter_cancelSpece; self.contanerView.frame = CGRectMake(0, [self safeScreenHeight] - width, alter_ScreenWidth, width); [self addSubview:self.contanerView]; UIButton *cancelButton = [self cancelButtonWithTitle:cancelTitle]; cancelButton.frame = CGRectMake(0, self.contanerView.frame.size.height - alter_actionHeight, alter_ScreenWidth, alter_actionHeight); [self.contanerView addSubview:cancelButton]; for (NSString *name in actionTitleArray) &#123; UIButton *button = [self setupActionWithTitle:name]; NSInteger index = [actionTitleArray indexOfObject:name]; button.tag = 1000 + index; button.frame = CGRectMake(0, alter_actionHeight * index, alter_ScreenWidth, alter_actionHeight-0.5); [self.contanerView addSubview:button]; &#125; self.conterViewRect = self.contanerView.frame; return self;&#125;/** Set events */- (LZAlterView *)configureWithActionTitleArray:(NSArray&lt;NSString *&gt; *)actionTitleArray &#123; CGFloat width = alter_actionHeight * actionTitleArray.count; self.contanerView.frame = CGRectMake(0, [self safeScreenHeight] - width, alter_ScreenWidth, width); [self addSubview:self.contanerView]; for (NSString *name in actionTitleArray) &#123; UIButton *button = [self setupActionWithTitle:name]; NSInteger index = [actionTitleArray indexOfObject:name]; button.tag = 1000 + index; button.frame = CGRectMake(0, alter_actionHeight * index, alter_ScreenWidth, alter_actionHeight-0.5); [self.contanerView addSubview:button]; &#125; self.conterViewRect = self.contanerView.frame; return self;&#125;/** Event button style */- (UIButton *)setupActionWithTitle:(NSString *)title &#123; UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; [button setTitle:title forState:UIControlStateNormal]; [button setTitleColor:UIColor.blackColor forState:UIControlStateNormal]; button.backgroundColor = [UIColor colorWithRed:0.9 green:0.9 blue:0.9 alpha:1]; button.titleLabel.font = alter_FontSize(15); [button addTarget:self action:@selector(buttonTouched:) forControlEvents:UIControlEventTouchUpInside]; return button;&#125;/** Cancel button style */- (UIButton *)cancelButtonWithTitle:(NSString *)title &#123; UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; [button setTitle:title forState:UIControlStateNormal]; [button setTitleColor:[UIColor colorWithRed:0.9 green:0 blue:0 alpha:1] forState:UIControlStateNormal]; button.backgroundColor = [UIColor colorWithRed:0.9 green:0.9 blue:0.9 alpha:1]; button.titleLabel.font = alter_FontSize(15); [button addTarget:self action:@selector(hidenAlter) forControlEvents:UIControlEventTouchUpInside]; return button;&#125;/** Title style */- (UILabel *)setupMainTitle:(NSString *)title subTitle:(NSString *)subTitle &#123; NSString *titleString; if (subTitle.length == 0) &#123; titleString = [NSString stringWithFormat:@"%@",title]; &#125; else &#123; titleString = [NSString stringWithFormat:@"%@\n%@",title,subTitle]; &#125; UILabel *label = [[UILabel alloc] init]; label.backgroundColor = [UIColor colorWithRed:0.9 green:0.9 blue:0.9 alpha:1]; label.textColor = UIColor.blackColor; label.font = alter_FontSize(15); NSMutableAttributedString *muAttribute = [[NSMutableAttributedString alloc] initWithString:titleString]; [muAttribute addAttribute:NSFontAttributeName value:alter_FontSize(12) range:NSMakeRange(titleString.length - subTitle.length, subTitle.length)]; [muAttribute addAttribute:NSForegroundColorAttributeName value:UIColor.grayColor range:NSMakeRange(titleString.length - subTitle.length, subTitle.length)]; label.textAlignment = NSTextAlignmentCenter; label.numberOfLines = 2; label.attributedText = muAttribute; return label;&#125;#pragma mark - Button click events and delegate- (void)buttonTouched:(UIButton *)sender &#123; [self hidenAlter]; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(alterView:didSelectedAtIndex:)]) &#123; [self.delegate alterView:self didSelectedAtIndex:sender.tag - 1000]; &#125;&#125;/** iOS 11 safeArea bottom space */- (CGFloat)safeScreenHeight &#123; CGFloat safeAreaInsetsBottom = 0; if (@available(iOS 11.0, *)) &#123; safeAreaInsetsBottom = UIApplication.sharedApplication.delegate.window.safeAreaInsets.bottom; &#125; else &#123; safeAreaInsetsBottom = 0; &#125; return alter_ScreenHeight - safeAreaInsetsBottom;&#125;#pragma mark - Show alter And hiden alter/** Show alter from bottom */- (void)showAlter &#123; [UIApplication.sharedApplication.delegate.window addSubview:self]; self.backgroundColor = [UIColor colorWithWhite:0 alpha:0.3]; self.frame = CGRectMake(0, 0, alter_ScreenWidth, alter_ScreenHeight); self.alpha = 0; self.contanerView.frame = CGRectMake(0, UIScreen.mainScreen.bounds.size.height, UIScreen.mainScreen.bounds.size.height, 0); [UIView animateWithDuration:0.4 animations:^&#123; self.alpha = 1; self.contanerView.frame = self.conterViewRect; &#125;];&#125;/** Hiden alter and remove subViews from superview */- (void)hidenAlter &#123; [UIView animateWithDuration:0.4 animations:^&#123; self.alpha = 0; self.contanerView.frame = CGRectMake(0, UIScreen.mainScreen.bounds.size.height, UIScreen.mainScreen.bounds.size.height, 0); &#125; completion:^(BOOL finished) &#123; for (UIView *view in self.contanerView.subviews) &#123; [view removeFromSuperview]; &#125; [self removeFromSuperview]; &#125;];&#125;#pragma mark - Getter- (UIView *)contanerView &#123; if (!_contanerView) &#123; _contanerView = [[UIView alloc] init]; _contanerView.backgroundColor = [UIColor colorWithRed:0.9 green:0.9 blue:0.9 alpha:0.5]; &#125; return _contanerView;&#125;#pragma mark - TapGestureRecognizer event- (void)tapGestureRecognizer:(id)sender &#123; [self hidenAlter];&#125;@end 3、使用方法，遵循LZAlterViewDelegate样式一1234567// Objc[[[[LZAlterView alter] configureWithMainTitle:@"选择图片" subTitle:@"1" actionTitleArray:@[@"打开相册", @"打开相机"] cancelActionTitle:@"取消"] setupDelegate:self] showAlter];// SwiftLZAlterView.alter().configure(withMainTitle: "选择图片", subTitle: "副标题", actionTitleArray: ["相机", "相册"], cancelActionTitle: "取消").setupDelegate(self).showAlter() 样式二123456// Objc [[[[LZAlterView alter] configureWithMainTitle:@"选择图片" subTitle:@"2" actionTitleArray:@[@"打开相册", @"打开相机"]] setupDelegate:self] showAlter];// SwiftLZAlterView.alter().configure(withMainTitle: "选择图片", subTitle: "需要用户权限", actionTitleArray: ["相机", "相册"]).setupDelegate(self).showAlter() 样式三12345// Objc[[[[LZAlterView alter] configureWithActionTitleArray:@[@"打开相册", @"打开相机"] cancelActionTitle:@"取消"] setupDelegate:self] showAlter];// SwiftLZAlterView.alter().configure(withActionTitleArray: ["相机", "相册"], cancelActionTitle: "取消").setupDelegate(self).showAlter() 样式四1234// Objc[[[[LZAlterView alter] configureWithActionTitleArray:@[@"打开相册", @"打开相机", @"拍照视频"]] setupDelegate:self] showAlter];// SwiftLZAlterView.alter().configure(withActionTitleArray: ["相机", "相册"]).setupDelegate(self).showAlter() 4、代理方法12345678910// Objc- (void)alterView:(LZAlterView *)alterView didSelectedAtIndex:(NSInteger)index &#123; NSLog(@"点击第%ld按钮", index);&#125;// Swiftextension ViewController: LZAlterViewDelegate &#123; func alterView(_ alterView: LZAlterView, didSelectedAt index: Int) &#123; print("点击第\(index)按钮") &#125;&#125; 5、效果图 结尾：有问题希望大家指正！😄😄😄]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS自定义控件：自定义分类下拉]]></title>
    <url>%2F2018%2F11%2F19%2FiOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E7%B1%BB%E4%B8%8B%E6%8B%89%2F</url>
    <content type="text"><![CDATA[最近自由时间有点多，就开始撸控件。这个是我们常用的一个下拉分类控件，看了很多别人写的，都是用TableView或者CollectionView整合在一起的感觉自定义性没有那么强，所以就尝试用把TableView和CollectionView替换成UIViewController。其他废话不多说了。 1、 接口文件123456789101112131415161718192021222324252627282930313233343536#import &lt;UIKit/UIKit.h&gt;UIKIT_EXTERN NSString *lzDropViewNotification;NS_ASSUME_NONNULL_BEGIN@class LZDropView;@protocol LZDropViewDataSource &lt;NSObject&gt;@required/** Height corresponding to controller display */- (NSArray&lt;NSNumber *&gt; *)setupCategoryControllerHeightInDropView:(LZDropView *)dropView;/** Title corresponding controller array */- (NSArray&lt;UIViewController *&gt; *)setupCategoryControllerInDropView:(LZDropView *)dropView;/** Default display of Title Array */- (NSArray&lt;NSString *&gt; *)setupCategoryTitleNameInDropView:(LZDropView *)dropView;@end@protocol LZDropViewDelegate &lt;NSObject&gt;/** Click the column and select the information. */- (void)dropView:(LZDropView *)dropView didSelectAtColumn:(NSInteger)column info:(NSString *)info;@end@interface LZDropView : UIView/** Simple page configuration */@property (nonatomic, weak) id &lt;LZDropViewDataSource&gt; dataSorce;/** Click proxy event&lt;##&gt; */@property (nonatomic, weak) id &lt;LZDropViewDelegate&gt; delegate;@endNS_ASSUME_NONNULL_END 2、 实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#import "LZDropView.h"NSString *lzDropViewNotification = @"nitification";@interface LZDropView ()@property (nonatomic, strong) NSArray&lt;UIViewController *&gt; *controllerArray;@property (nonatomic, strong) NSArray&lt;NSString *&gt; *titleArray;@property (nonatomic, strong) UIButton *containerView;@property (nonatomic, strong) NSArray&lt;NSNumber *&gt; *controllerHeightArray;@property (nonatomic, strong) NSMutableArray&lt;UIButton *&gt; *buttonArray;@end@implementation LZDropView#pragma mark - Release memory- (void)dealloc &#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125;#pragma mark - Initialization- (instancetype)init &#123; self = [super init]; if (self) &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notificationAction:) name:lzDropViewNotification object:nil]; &#125; return self;&#125;#pragma mark - Draw the page- (void)setupTitleButton:(NSArray&lt;NSString *&gt; *)array &#123; CGFloat width = UIScreen.mainScreen.bounds.size.width / array.count; self.buttonArray = [NSMutableArray array]; for (NSString *name in array) &#123; NSInteger index = [array indexOfObject:name]; UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; button.titleLabel.font = [UIFont systemFontOfSize:15]; [button setTitle:[NSString stringWithFormat:@"%@ ▼", name] forState:UIControlStateNormal]; [button setTitle:[NSString stringWithFormat:@"%@ ▲", name] forState:UIControlStateSelected]; [button setTitleColor:UIColor.grayColor forState:UIControlStateNormal]; [button setTitleColor:UIColor.orangeColor forState:UIControlStateSelected]; button.frame = CGRectMake(width * index, 0, width, 45); button.tag = index + 1000; [button addTarget:self action:@selector(buttonTouched:) forControlEvents:UIControlEventTouchUpInside]; [self addSubview:button]; [self.buttonArray addObject:button]; &#125;&#125;#pragma mark - Button click event- (void)buttonTouched:(UIButton *)sender &#123; if (sender.selected) &#123; [self closeControllerView]; &#125; else &#123; [self openControllerViewWithButton:sender]; &#125;&#125;- (void)backButtonTouched:(UIButton *)sender &#123; [self closeControllerView];&#125;#pragma mark - Notification event- (void)notificationAction:(NSNotification *)notification &#123; if (![self.controllerArray containsObject:notification.object]) &#123; return; &#125; NSInteger index = [self.controllerArray indexOfObject:notification.object]; UIButton *button = self.buttonArray[index]; [button setTitle:[NSString stringWithFormat:@"%@ ▼", notification.userInfo.allValues.firstObject] forState:UIControlStateNormal]; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dropView:didSelectAtColumn:info:)]) &#123; [self.delegate dropView:self didSelectAtColumn:index info:notification.userInfo.allValues.firstObject]; &#125; [self closeControllerView];&#125;#pragma mark - Close all controllers.- (void)closeControllerView &#123; [UIView animateWithDuration:0.8 animations:^&#123; self.containerView.alpha = 0; self.containerView.frame = CGRectMake(0, CGRectGetMaxY(self.frame), UIScreen.mainScreen.bounds.size.width, 0); &#125; completion:^(BOOL finished) &#123; [self.containerView removeFromSuperview]; &#125;]; for (UIButton *button in self.buttonArray) &#123; button.selected = false; &#125;&#125;#pragma mark - Open the corresponding controller.- (void)openControllerViewWithButton:(UIButton *)sender &#123; for (UIButton *button in self.buttonArray) &#123; button.selected = false; &#125; self.containerView.alpha = 1; for (UIView *view in self.containerView.subviews) &#123; [view removeFromSuperview]; &#125; UIViewController *vc = self.controllerArray[sender.tag - 1000]; double vcHeight = [self.controllerHeightArray[sender.tag - 1000] doubleValue]; self.containerView.frame = CGRectMake(0, CGRectGetMaxY(self.frame), self.frame.size.width, 0); vc.view.frame = CGRectMake(0, 0, UIScreen.mainScreen.bounds.size.width, 0); [self.superview addSubview:self.containerView]; [self.containerView addSubview:vc.view]; [UIView animateWithDuration:0.6 animations:^&#123; self.containerView.frame = CGRectMake(0, CGRectGetMaxY(self.frame), self.frame.size.width, UIScreen.mainScreen.bounds.size.height); vc.view.frame = CGRectMake(0, 0, UIScreen.mainScreen.bounds.size.width, vcHeight); &#125; completion:^(BOOL finished) &#123; &#125;]; sender.selected = true;&#125;#pragma mark - Getter- (UIView *)containerView &#123; if (!_containerView) &#123; _containerView = [[UIButton alloc] init]; _containerView.backgroundColor = [UIColor colorWithWhite:0 alpha:0.1]; [_containerView addTarget:self action:@selector(backButtonTouched:) forControlEvents:UIControlEventTouchUpInside]; &#125; return _containerView;&#125;#pragma mark - Setter- (void)setDataSorce:(id&lt;LZDropViewDataSource&gt;)dataSorce &#123; _dataSorce = dataSorce; if (self.dataSorce &amp;&amp; [self.dataSorce respondsToSelector:@selector(setupCategoryControllerInDropView:)])&#123; self.controllerArray = [self.dataSorce setupCategoryControllerInDropView:self]; &#125; if (self.dataSorce &amp;&amp; [self.dataSorce respondsToSelector:@selector(setupCategoryTitleNameInDropView:)])&#123; self.titleArray = [self.dataSorce setupCategoryTitleNameInDropView:self]; [self setupTitleButton:self.titleArray]; &#125; if (self.dataSorce &amp;&amp; [self.dataSorce respondsToSelector:@selector(setupCategoryControllerHeightInDropView:)]) &#123; self.controllerHeightArray = [self.dataSorce setupCategoryControllerHeightInDropView:self]; &#125; if (self.controllerArray.count != self.titleArray.count || self.controllerArray.count != self.controllerHeightArray.count) &#123; @throw [NSException exceptionWithName:NSStringFromClass([self class]) reason:@"The number of corresponding arrays is inconsistent." userInfo:nil]; &#125;&#125;@end 使用方式 1.遵循协议1&lt;LZDropViewDataSource, LZDropViewDelegate&gt; 2.初始化123456LZDropView *view = [[LZDropView alloc] init]; view.dataSorce = self; view.delegate = self; view.backgroundColor = UIColor.whiteColor; view.frame = CGRectMake(0, 100, UIScreen.mainScreen.bounds.size.width, 45); [self.view addSubview:view]; 实现代理和数据源 12345678910111213141516171819202122232425262728#pragma mark - LZDropViewDataSource- (NSArray&lt;UIViewController *&gt; *)setupCategoryControllerInDropView:(LZDropView *)dropView &#123; return @[[[TableViewController alloc] init], [[TableViewController alloc] init], [[TableViewController alloc] init], [[TableViewController alloc] init]];&#125;- (NSArray&lt;NSString *&gt; *)setupCategoryTitleNameInDropView:(LZDropView *)dropView &#123; return @[@"全部", @"附近", @"只能排序", @"筛选"];&#125;- (NSArray&lt;NSNumber *&gt; *)setupCategoryControllerHeightInDropView:(LZDropView *)dropView &#123; return @[[NSNumber numberWithFloat:300], [NSNumber numberWithFloat:400], [NSNumber numberWithFloat:410], [NSNumber numberWithFloat:420]];&#125;#pragma mark - LZDropViewDelegate- (void)dropView:(LZDropView *)dropView didSelectAtColumn:(NSInteger)column info:(NSString *)info &#123; NSLog(@"%ld---%@", column, info);&#125; 点击controller中的数据显示在按钮的标题中，这因为跨界面显示，我暂时没有想到好的办法，所以使用强大的通知传值。 记录选中状态，应该是控制器里面的操作，这里就没有实现1[[NSNotificationCenter defaultCenter] postNotificationName:lzDropViewNotification object:self userInfo:@&#123;@"key":[NSString stringWithFormat:@"第%ldcell", indexPath.row]&#125;]; 如果有什么不好如果建议的地方，请批评指正！]]></content>
  </entry>
  <entry>
    <title><![CDATA[系统SDK介绍-02]]></title>
    <url>%2F2018%2F11%2F08%2F%E7%B3%BB%E7%BB%9FSDK%E5%B0%81%E8%A3%85-02%2F</url>
    <content type="text"><![CDATA[系统SDK介绍 打开相册选择图片 打开相册选择视频 打开相机拍摄图片 打开相机拍摄视频 配置权限：在info.plist文件中添加需要的权限 相机权限：Privacy - Camera Usage Description 允许此权限才能使用相机功，这样才能录制视频，并且想要保存图片。 相册权限：Privacy - Photo Library Usage Description 允许此权限才能使用系统相册。 麦克风权限：Privacy - Microphone Usage Description 获取麦克风权限不然会崩，只有允许此权限才能录音。 判断是否权限123456789#pragma mark - 权限判断- (BOOL)authorizationCamera &#123; NSString *mediaType = AVMediaTypeVideo; AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:mediaType]; if(authStatus == AVAuthorizationStatusRestricted || authStatus == AVAuthorizationStatusDenied)&#123; return false; &#125; return true;&#125; 配置选项123456789typedef NS_ENUM(NSInteger, LZSystemPhotoSelectorType) &#123; LZSystemPhotoSelectorTypeVideo, // 选择视频 LZSystemPhotoSelectorTypePhoto, // 选择图片&#125;;typedef NS_ENUM(NSInteger, LZSystemOpenDeviceType) &#123; LZSystemOpenDeviceTypeCamera, // 打开相机 LZSystemOpenDeviceTypeVideo, // 打开摄像机&#125;; 接口文件1234567891011121314151617181920212223242526272829303132333435363738394041#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGINtypedef NS_ENUM(NSInteger, LZSystemPhotoSelectorType) &#123; LZSystemPhotoSelectorTypeVideo, // 选择视频 LZSystemPhotoSelectorTypePhoto, // 选择图片&#125;;typedef NS_ENUM(NSInteger, LZSystemOpenDeviceType) &#123; LZSystemOpenDeviceTypeCamera, // 打开相机 LZSystemOpenDeviceTypeVideo, // 打开摄像机&#125;;@interface LZSystemPhotoSelector : NSObject+ (instancetype)selector;/** 选择图片或视频 @param type 类型 @param allowsEditing 是否允许编辑 @param resultFile 选择结果，图片是UIImage 视频是NSUrl */- (void)lz_openAblumWithType:(LZSystemPhotoSelectorType)type allowsEditing:(BOOL)allowsEditing resultFile:(void(^)(id info))resultFile;/** 打开相机或摄像机 @param type 类型 @param allowsEditing 是否拍摄完成进行编辑 @param resultFile 选择结果，图片是UIImage 视频是NSUrl */- (void)lz_openDeviceWithType:(LZSystemOpenDeviceType)type allowsEditing:(BOOL)allowsEditing resultFile:(void(^)(id info))resultFile;@endNS_ASSUME_NONNULL_END 实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#import "LZSystemPhotoSelector.h"#import &lt;UIKit/UIKit.h&gt;#import &lt;AVFoundation/AVFoundation.h&gt;#import &lt;AssetsLibrary/AssetsLibrary.h&gt;#import &lt;MobileCoreServices/MobileCoreServices.h&gt;#define kRootViewController UIApplication.sharedApplication.delegate.window.rootViewController@interface LZSystemPhotoSelector () &lt;UIImagePickerControllerDelegate, UINavigationControllerDelegate&gt;@property (nonatomic, copy) void (^resultFile)(id info);@property (nonatomic, assign) BOOL allowsEditing;@end@implementation LZSystemPhotoSelector+ (instancetype)selector &#123; static dispatch_once_t onceToken; static LZSystemPhotoSelector *selector; dispatch_once(&amp;onceToken, ^&#123; selector = [[LZSystemPhotoSelector alloc] init]; &#125;); return selector;&#125;#pragma mark - 选择图片或视频- (void)lz_openAblumWithType:(LZSystemPhotoSelectorType)type allowsEditing:(BOOL)allowsEditing resultFile:(void(^)(id info))resultFile &#123; if (![UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypePhotoLibrary]) &#123; resultFile(@"该设备暂时不支持"); return; &#125; self.allowsEditing = allowsEditing; self.resultFile = resultFile; UIImagePickerController *controller = [[UIImagePickerController alloc] init]; controller.delegate = self; controller.sourceType = UIImagePickerControllerSourceTypePhotoLibrary; if (type == LZSystemPhotoSelectorTypePhoto) &#123; controller.mediaTypes = [NSArray arrayWithObjects:@"public.image", nil]; &#125; else &#123; controller.mediaTypes = [NSArray arrayWithObjects:@"public.movie", nil]; &#125; controller.allowsEditing = allowsEditing; [kRootViewController presentViewController:controller animated:true completion:nil];&#125;#pragma mark - 打开相机或摄像机- (void)lz_openDeviceWithType:(LZSystemOpenDeviceType)type allowsEditing:(BOOL)allowsEditing resultFile:(void (^)(id _Nonnull))resultFile &#123; if (![UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) &#123; resultFile(@"该设备暂时不支持"); return; &#125; if (![self authorizationCamera]) &#123; resultFile(@"暂无相机权限"); return; &#125; self.allowsEditing = allowsEditing; self.resultFile = resultFile; UIImagePickerController *controller = [[UIImagePickerController alloc] init]; controller.delegate = self; controller.sourceType = UIImagePickerControllerSourceTypeCamera; if (type == LZSystemOpenDeviceTypeCamera) &#123; controller.mediaTypes = [NSArray arrayWithObjects:@"public.image", nil]; &#125; else &#123; controller.mediaTypes = [NSArray arrayWithObjects:@"public.movie", nil]; &#125; controller.allowsEditing = allowsEditing; [kRootViewController presentViewController:controller animated:true completion:nil];&#125;#pragma mark - UIImagePickerControllerDelegate- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info &#123; NSString *mediaType = [info objectForKey:UIImagePickerControllerMediaType]; if ([mediaType isEqualToString:(NSString *)kUTTypeImage]) &#123; if (self.allowsEditing) &#123; UIImage *editorImage = info[UIImagePickerControllerEditedImage]; self.resultFile(editorImage); &#125; else &#123; UIImage *editorImage = info[UIImagePickerControllerOriginalImage]; self.resultFile(editorImage); &#125; &#125; else &#123; NSURL *url = info[UIImagePickerControllerMediaURL]; self.resultFile(url); &#125; [picker dismissViewControllerAnimated:true completion:nil];&#125;- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker &#123; [picker dismissViewControllerAnimated:true completion:nil];&#125;#pragma mark - 权限判断- (BOOL)authorizationCamera &#123; NSString *mediaType = AVMediaTypeVideo; AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:mediaType]; if(authStatus == AVAuthorizationStatusRestricted || authStatus == AVAuthorizationStatusDenied)&#123; return false; &#125; return true;&#125;@end]]></content>
  </entry>
  <entry>
    <title><![CDATA[系统SDK介绍-01]]></title>
    <url>%2F2018%2F11%2F08%2F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8-01%2F</url>
    <content type="text"><![CDATA[系统SDK介绍 访问联系人，并选择信息 拨号 发送短信 发送邮件 本地通知 接口文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#import &lt;Foundation/Foundation.h&gt;#import &lt;ContactsUI/ContactsUI.h&gt;NS_ASSUME_NONNULL_BEGIN@interface LZSystemSDKManager : NSObject+ (instancetype)manager;/** 选择联系人 先添加权限 @param result 选择的信息 */- (void)lz_selecteContactResulet:(void(^)(CNContact *obj))result API_AVAILABLE(ios(9.0));/** 发送邮件 @param toRecipients 收件人群组 @param ccRecipients 抄送人群组 @param bccRecipients 密送人群组 @param theme 主题 @param emailContent 正文内容 @param isHTML 是否是HTML格式 @param result 发送结果 */- (void)lz_postEmialWithToRecipients:(NSArray&lt;NSString *&gt; *)toRecipients ccRecipients:(NSArray&lt;NSString *&gt; *)ccRecipients bccRecipients:(NSArray&lt;NSString *&gt; *)bccRecipients theme:(NSString *)theme emailContent:(NSString *)emailContent isHTML:(BOOL)isHTML reslt:(void(^)(NSInteger))result;/** 发送短信 @param toRecipients 收件人群组 @param content 内容 @param result 发送结果 */- (void)lz_sendMessageWithToRecipients:(NSArray&lt;NSString *&gt; *)toRecipients content:(NSString *)content reslt:(void(^)(NSInteger))result;/** 拨号 @param phoneNum 号码 */- (void)lz_dailPhone:(NSString *)phoneNum;/** 开启定位服务 @param localResult 定位获取信息 */- (void)lz_openLocationService:(void(^)(id info))localResult;/** IOS 10的通知 推送消息 支持的音频 图片 &lt;= 10M 视频 &lt;= 50M @param body 消息内容 @param promptTone 提示音 @param soundName 音频 @param imageName 图片 @param movieName 视频 @param identifier 消息标识 */-(void)lz_pushNotification_IOS_10_Title:(NSString *)title subtitle:(NSString *)subtitle body:(NSString *)body promptTone:(NSString *)promptTone soundName:(NSString *)soundName imageName:(NSString *)imageName movieName:(NSString *)movieName timeInterval:(NSTimeInterval)TimeInterval repeats:(BOOL)repeats Identifier:(NSString *)identifier API_AVAILABLE(ios(10.0));/** IOS 10前的通知 @param timeInterval 延迟时间 @param repeatInterval 重复提醒次数 @param alertBody 内容 @param alertTitle 标题 @param alertAction 滑动文字 @param alertLaunchImage alertLaunchImage @param soundName 声音 为空则为系统声音 @param userInfo 字典参数 */- (void)lz_pushNotifationWithTimeInterval:(NSTimeInterval)timeInterval repeatInterval:(NSInteger)repeatInterval alertBody:(NSString *)alertBody alertTitle:(NSString *)alertTitle alertAction:(NSString *)alertAction alertLaunchImage:(NSString *)alertLaunchImage soundName:(NSString *)soundName userInfo:(NSDictionary *)userInfo;@endNS_ASSUME_NONNULL_END 实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#import "LZSystemSDKManager.h"#import &lt;UIKit/UIKit.h&gt;#import &lt;MessageUI/MessageUI.h&gt;#import &lt;CoreLocation/CoreLocation.h&gt;#import &lt;UserNotifications/UserNotifications.h&gt;#define kRootViewController UIApplication.sharedApplication.delegate.window.rootViewController@interface LZSystemSDKManager () &lt; CNContactPickerDelegate, MFMailComposeViewControllerDelegate, MFMessageComposeViewControllerDelegate, CLLocationManagerDelegate&gt;@property (nonatomic, copy) void (^selectContactResult)(CNContact *obj) API_AVAILABLE(ios(9.0));@property (nonatomic, copy) void (^postEmailResult)(NSInteger obj);@property (nonatomic, copy) void (^sendMessageResult)(NSInteger obj);@property (nonatomic, copy) void (^locakResult)(id info);@end@implementation LZSystemSDKManager+ (instancetype)manager &#123; static dispatch_once_t onceToken; static LZSystemSDKManager *manager; dispatch_once(&amp;onceToken, ^&#123; manager = [[LZSystemSDKManager alloc] init]; &#125;); return manager;&#125;#pragma mark - 选择联系人信息- (void)lz_selecteContactResulet:(void(^)(CNContact *obj))result API_AVAILABLE(ios(9.0)) &#123; self.selectContactResult = result; CNAuthorizationStatus status = [CNContactStore authorizationStatusForEntityType:CNEntityTypeContacts]; if (status == CNAuthorizationStatusNotDetermined) &#123; CNContactStore *store = [[CNContactStore alloc] init]; [store requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; if (error) &#123; [self showHUDTitle:@"未获取访问权限" info:@"请前往设置中打开访问权限"]; &#125; else &#123; CNContactPickerViewController * picker = [CNContactPickerViewController new]; picker.delegate = self; picker.displayedPropertyKeys = @[CNContactPhoneNumbersKey]; [kRootViewController presentViewController: picker animated:YES completion:nil]; &#125; &#125;]; &#125; if (status == CNAuthorizationStatusAuthorized) &#123; CNContactPickerViewController * picker = [CNContactPickerViewController new]; picker.delegate = self; picker.displayedPropertyKeys = @[CNContactPhoneNumbersKey]; [kRootViewController presentViewController: picker animated:YES completion:nil]; &#125; else&#123; [self showHUDTitle:@"未获取访问权限" info:@"请前往设置中打开访问权限"]; &#125;&#125;#pragma mark - CNContactPickerDelegate- (void)contactPicker:(CNContactPickerViewController *)picker didSelectContactProperty:(CNContactProperty *)contactProperty API_AVAILABLE(ios(9.0)) &#123; CNContact *contact = contactProperty.contact; self.selectContactResult(contact);&#125;#pragma mark - 发送邮件- (void)lz_postEmialWithToRecipients:(NSArray&lt;NSString *&gt; *)toRecipients ccRecipients:(NSArray&lt;NSString *&gt; *)ccRecipients bccRecipients:(NSArray&lt;NSString *&gt; *)bccRecipients theme:(NSString *)theme emailContent:(NSString *)emailContent isHTML:(BOOL)isHTML reslt:(nonnull void (^)(NSInteger))result &#123; self.postEmailResult = result; MFMailComposeViewController *mailCompose = [[MFMailComposeViewController alloc] init]; mailCompose.mailComposeDelegate = self; [mailCompose setToRecipients:toRecipients]; [mailCompose setCcRecipients:ccRecipients]; [mailCompose setBccRecipients:bccRecipients]; [mailCompose setSubject:theme]; [mailCompose setMessageBody:emailContent isHTML:isHTML]; [kRootViewController presentViewController:mailCompose animated:YES completion:nil];&#125;#pragma mark - MFMailComposeViewControllerDelegate的代理方法：-(void)mailComposeController:(MFMailComposeViewController *)controller didFinishWithResult:(MFMailComposeResult)result error:(NSError *)error &#123; [controller dismissViewControllerAnimated:YES completion:nil]; self.postEmailResult(result);&#125;#pragma mark - 发送短信- (void)lz_sendMessageWithToRecipients:(NSArray&lt;NSString *&gt; *)toRecipients content:(NSString *)content reslt:(nonnull void (^)(NSInteger))result &#123; self.sendMessageResult = result; MFMessageComposeViewController *messageVC = [[MFMessageComposeViewController alloc] init]; messageVC.recipients = toRecipients; messageVC.body = content; messageVC.messageComposeDelegate = self; [kRootViewController presentViewController:messageVC animated:YES completion:nil];&#125;#pragma mark - MFMessageComposeViewControllerDelegate- (void)messageComposeViewController:(MFMessageComposeViewController *)controller didFinishWithResult:(MessageComposeResult)result &#123; [controller dismissViewControllerAnimated:true completion:nil]; self.sendMessageResult(result);&#125;#pragma mark - 拨号- (void)lz_dailPhone:(NSString *)phoneNum &#123; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:[NSString stringWithFormat:@"tel:%@",phoneNum]]];&#125;#pragma mark - 定位服务- (void)lz_openLocationService:(void(^)(id info))localResult &#123; self.locakResult = localResult; CLLocationManager *localManager = [[CLLocationManager alloc] init]; localManager.delegate = self; localManager.desiredAccuracy = kCLLocationAccuracyBest; localManager.distanceFilter = kCLLocationAccuracyNearestTenMeters; [localManager requestWhenInUseAuthorization]; if ([CLLocationManager locationServicesEnabled] || [CLLocationManager authorizationStatus] == kCLAuthorizationStatusAuthorizedWhenInUse || [CLLocationManager authorizationStatus] == kCLAuthorizationStatusAuthorizedAlways) &#123; [localManager startUpdatingLocation]; &#125; else &#123; [self showHUDTitle:@"未获取定位权限" info:@"请前往设置中打开定位权限"]; &#125;&#125;#pragma mark CLLocationManagerDelegate- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations &#123; CLLocation *currLocation = [locations lastObject]; CLLocation *infLocation = [[CLLocation alloc] initWithLatitude:currLocation.coordinate.latitude longitude:currLocation.coordinate.longitude]; CLGeocoder *geocoder=[[CLGeocoder alloc]init]; [geocoder reverseGeocodeLocation:infLocation completionHandler:^(NSArray&lt;CLPlacemark *&gt; * _Nullable placemarks, NSError * _Nullable error) &#123; if (error !=nil || placemarks.count == 0) &#123; NSLog(@"%@",error); self.locakResult(nil); return ; &#125; NSDictionary *infoDic = @&#123;@"country":placemarks.firstObject.country, @"administrativeArea":placemarks.firstObject.administrativeArea, @"locality":placemarks.firstObject.locality, @"subLocality":placemarks.firstObject.subLocality, @"thoroughfare":placemarks.firstObject.thoroughfare, @"name":placemarks.firstObject.name &#125;; self.locakResult(infoDic); &#125;];&#125;-(void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error &#123; [self showHUDTitle:@"未获取定位权限" info:@"请前往设置中打开定位权限"];&#125;#pragma mark - 提示框- (void)showHUDTitle:(NSString *)title info:(NSString *)info &#123; UIAlertController *alterController = [UIAlertController alertControllerWithTitle:title message:info preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *cancal = [UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:nil]; UIAlertAction *sure = [UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDestructive handler:^(UIAlertAction * _Nonnull action) &#123; NSURL *url = [NSURL URLWithString:UIApplicationOpenSettingsURLString]; if ([[UIApplication sharedApplication] canOpenURL:url]) &#123; if (@available(iOS 10.0, *)) &#123; [[UIApplication sharedApplication] openURL:url options:@&#123;&#125; completionHandler:nil]; &#125; else &#123; &#125; &#125; &#125;]; [alterController addAction:cancal]; [alterController addAction:sure]; [kRootViewController presentViewController:alterController animated:true completion:nil];&#125;#pragma mark - IOS 10前的通知- (void)lz_pushNotifationWithTimeInterval:(NSTimeInterval)timeInterval repeatInterval:(NSInteger)repeatInterval alertBody:(NSString *)alertBody alertTitle:(NSString *)alertTitle alertAction:(NSString *)alertAction alertLaunchImage:(NSString *)alertLaunchImage soundName:(NSString *)soundName userInfo:(NSDictionary *)userInfo &#123; // 定义本地通知对象 UILocalNotification *notification = [[UILocalNotification alloc] init]; // 设置调用时间 notification.timeZone = [NSTimeZone localTimeZone]; //通知触发的时间，10s以后 notification.fireDate = [NSDate dateWithTimeIntervalSinceNow:timeInterval]; // 通知重复次数 notification.repeatInterval = repeatInterval; // 当前日历，使用前最好设置时区等信息以便能够自动同步时间 notification.repeatCalendar = [NSCalendar currentCalendar]; //设置通知属性 // 通知主体 notification.alertBody = alertBody; if (@available(iOS 8.2, *)) &#123; notification.alertTitle = alertTitle; &#125; else &#123; // Fallback on earlier versions &#125; // 应用程序图标右上角显示的消息数 notification.applicationIconBadgeNumber += 1; // 待机界面的滑动动作提示 notification.alertAction = alertAction; // 通过点击通知打开应用时的启动图片,这里使用程序启动图片 notification.alertLaunchImage = alertLaunchImage; // 收到通知时播放的声音，默认消息声音 notification.soundName = soundName.length == 0 ? UILocalNotificationDefaultSoundName : soundName; //设置用户信息 notification.userInfo = userInfo; //调用通知 [[UIApplication sharedApplication] scheduleLocalNotification:notification];&#125;#pragma mark - IOS 10的通知-(void)lz_pushNotification_IOS_10_Title:(NSString *)title subtitle:(NSString *)subtitle body:(NSString *)body promptTone:(NSString *)promptTone soundName:(NSString *)soundName imageName:(NSString *)imageName movieName:(NSString *)movieName timeInterval:(NSTimeInterval)TimeInterval repeats:(BOOL)repeats Identifier:(NSString *)identifier API_AVAILABLE(ios(10.0)) &#123; //获取通知中心用来激活新建的通知 UNUserNotificationCenter * center = [UNUserNotificationCenter currentNotificationCenter]; UNMutableNotificationContent * content = [[UNMutableNotificationContent alloc] init]; content.title = title; content.subtitle = subtitle; content.body = body; //通知的提示音 if ([promptTone containsString:@"."]) &#123; UNNotificationSound *sound = [UNNotificationSound soundNamed:promptTone]; content.sound = sound; &#125; __block UNNotificationAttachment *imageAtt; __block UNNotificationAttachment *movieAtt; __block UNNotificationAttachment *soundAtt; if ([imageName containsString:@"."]) &#123; [self addNotificationAttachmentContent:content attachmentName:imageName options:nil withCompletion:^(NSError *error, UNNotificationAttachment *notificationAtt) &#123; imageAtt = [notificationAtt copy]; &#125;]; &#125; if ([soundName containsString:@"."]) &#123; [self addNotificationAttachmentContent:content attachmentName:soundName options:nil withCompletion:^(NSError *error, UNNotificationAttachment *notificationAtt) &#123; soundAtt = [notificationAtt copy]; &#125;]; &#125; if ([movieName containsString:@"."]) &#123; // 在这里截取视频的第10s为视频的缩略图 ：UNNotificationAttachmentOptionsThumbnailTimeKey [self addNotificationAttachmentContent:content attachmentName:movieName options:@&#123;@"UNNotificationAttachmentOptionsThumbnailTimeKey":@10&#125; withCompletion:^(NSError *error, UNNotificationAttachment *notificationAtt) &#123; movieAtt = [notificationAtt copy]; &#125;]; &#125; NSMutableArray * array = [NSMutableArray array]; if (imageAtt) &#123; [array addObject:imageAtt]; &#125; if (soundAtt) &#123; [array addObject:soundAtt]; &#125; if (movieAtt) &#123; [array addObject:movieAtt]; &#125; content.attachments = array; //添加通知下拉动作按钮 NSMutableArray * actionMutableArray = [NSMutableArray array]; UNNotificationAction * actionA = [UNNotificationAction actionWithIdentifier:@"identifierNeedUnlock" title:@"进入应用" options:UNNotificationActionOptionAuthenticationRequired]; UNNotificationAction * actionB = [UNNotificationAction actionWithIdentifier:@"identifierRed" title:@"忽略" options:UNNotificationActionOptionDestructive]; [actionMutableArray addObjectsFromArray:@[actionA,actionB]]; if (actionMutableArray.count &gt; 1) &#123; UNNotificationCategory * category = [UNNotificationCategory categoryWithIdentifier:@"categoryNoOperationAction" actions:actionMutableArray intentIdentifiers:@[] options:UNNotificationCategoryOptionCustomDismissAction]; [center setNotificationCategories:[NSSet setWithObjects:category, nil]]; content.categoryIdentifier = @"categoryNoOperationAction"; &#125; // UNTimeIntervalNotificationTrigger 延时推送 // UNCalendarNotificationTrigger 定时推送 // UNLocationNotificationTrigger 位置变化推送 BOOL repeat = (TimeInterval &gt; 60 &amp;&amp; repeats) ? true : false; UNTimeIntervalNotificationTrigger * tirgger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:TimeInterval repeats:repeat]; //建立通知请求 UNNotificationRequest * request = [UNNotificationRequest requestWithIdentifier:identifier content:content trigger:tirgger]; //将建立的通知请求添加到通知中心 [center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; NSLog(@"%@本地推送 :( 报错 %@",identifier, error); &#125;];&#125;/** 增加通知附件 @param content 通知内容 @param attachmentName 附件名称 @param options 相关选项 @param completion 结果回调 */-(void)addNotificationAttachmentContent:(UNMutableNotificationContent *)content attachmentName:(NSString *)attachmentName options:(NSDictionary *)options withCompletion:(void(^)(NSError * error , UNNotificationAttachment * notificationAtt))completion API_AVAILABLE(ios(10.0)) &#123; NSArray * arr = [attachmentName componentsSeparatedByString:@"."]; NSError * error; NSString * path = [[NSBundle mainBundle]pathForResource:arr[0] ofType:arr[1]]; UNNotificationAttachment * attachment = [UNNotificationAttachment attachmentWithIdentifier:[NSString stringWithFormat:@"notificationAtt_%@",arr[1]] URL:[NSURL fileURLWithPath:path] options:options error:&amp;error]; if (error) &#123; NSLog(@"attachment error %@", error); &#125; completion(error,attachment); content.launchImageName = attachmentName;&#125;@end]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS系统封装：QQ侧边菜单]]></title>
    <url>%2F2018%2F09%2F30%2FiOS%E7%B3%BB%E7%BB%9F%E5%B0%81%E8%A3%85%EF%BC%9AQQ%E4%BE%A7%E8%BE%B9%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@interface LZSliderContainerViewController : UIViewController// 是否允许侧滑手势@property (nonatomic, assign) BOOL allowOpenSliderView;// 单例+ (instancetype)mamager;/** 初始化方法 @param mainController 主页面控制器 @param sliderController 菜单页面控制器 @param space 空隙 @return UIViewController */- (UIViewController *)lz_setupMainController:(UIViewController *)mainController sliderController:(UIViewController *)sliderController space:(CGFloat)space;/** 打开侧边菜单 */- (void)lz_openSlderView;/** 关闭侧边菜单 */- (void)lz_closeSliderView;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#import "LZSliderContainerViewController.h"@interface UIView (Frame)@property (nonatomic) CGFloat left;@property (nonatomic) CGFloat right;@end@implementation UIView (Frame)- (CGFloat)left &#123; return self.frame.origin.x;&#125;- (void)setLeft:(CGFloat)x &#123; CGRect frame = self.frame; frame.origin.x = x; self.frame = frame;&#125;- (CGFloat)right &#123; return self.frame.origin.x + self.frame.size.width;&#125;- (void)setRight:(CGFloat)right &#123; CGRect frame = self.frame; frame.origin.x = right - frame.size.width; self.frame = frame;&#125;@end@interface LZSliderContainerViewController ()@property (nonatomic, strong) UIViewController *mainController;@property (nonatomic, strong) UIViewController *sliderController;@property (nonatomic, assign) CGFloat spece;@property (nonatomic, assign) CGFloat panStartX;@property (nonatomic, strong) UIView *coverView;@end@implementation LZSliderContainerViewController#pragma mark - 单例方法+ (instancetype)mamager &#123; static dispatch_once_t onceToken; static LZSliderContainerViewController *vc; dispatch_once(&amp;onceToken, ^&#123; vc = [[LZSliderContainerViewController alloc] init]; &#125;); return vc;&#125;#pragma mark - 初始化方法- (UIViewController *)lz_setupMainController:(UIViewController *)mainController sliderController:(UIViewController *)sliderController space:(CGFloat)space &#123; [self lz_addChildControllerWithMainController:mainController sliderController:sliderController]; [self lz_setupCoverView]; _spece = space; return self;&#125;#pragma mark - 配置遮罩层- (void)lz_setupCoverView &#123; self.coverView = [[UIView alloc] init]; self.coverView.frame = UIScreen.mainScreen.bounds; self.coverView.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent:0]; self.coverView.hidden = true; [self.coverView addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(lz_closeSliderView)]]; [self.view addSubview:self.coverView];&#125;#pragma mark - 添加VC- (void)lz_addChildControllerWithMainController:(UIViewController *)mainController sliderController:(UIViewController *)sliderController &#123; [self addChildViewController:mainController]; [mainController didMoveToParentViewController:self]; mainController.view.frame = UIScreen.mainScreen.bounds; [self.view addSubview:mainController.view]; [self addChildViewController:sliderController]; [sliderController didMoveToParentViewController:self]; sliderController.view.frame = CGRectMake(-UIScreen.mainScreen.bounds.size.width, 0, UIScreen.mainScreen.bounds.size.width, UIScreen.mainScreen.bounds.size.height); [self.view addSubview:sliderController.view]; self.mainController = mainController; self.sliderController = sliderController; [self lz_setupGusture];&#125;#pragma mark - 添加平移手势- (void)lz_setupGusture &#123; UIPanGestureRecognizer *panGusture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(lz_panGestureRecognizer:)]; [self.view addGestureRecognizer:panGusture];&#125;#pragma mark - UIPanGestureRecognizer Action- (void)lz_panGestureRecognizer:(UIPanGestureRecognizer *)sender &#123; UIView *rootView = self.mainController.view; UIView *menuView = self.sliderController.view; if (sender.state == UIGestureRecognizerStateBegan) &#123; CGFloat startPointX = [sender translationInView:self.view].x; self.panStartX = startPointX; self.coverView.hidden = false; &#125; if (self.panStartX &gt;= 40 &amp;&amp; rootView.frame.origin.x == 0) &#123; return; &#125; CGFloat translationX = [sender translationInView:rootView].x; CGFloat rootViewX = rootView.frame.origin.x; rootViewX = [self lz_minmumWithValueA:(rootViewX + translationX) valueB:(UIScreen.mainScreen.bounds.size.width - self.spece)]; rootViewX = [self lz_maxmumWithValueA:rootViewX valueB:0]; rootView.left = rootViewX; menuView.right = rootView.left; self.coverView.frame = rootView.frame; CGFloat aphal = 0.5 * rootView.frame.origin.x / (UIScreen.mainScreen.bounds.size.width - self.spece); self.coverView.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent:aphal]; [sender setTranslation:CGPointZero inView:rootView]; if (sender.state == UIGestureRecognizerStateEnded || sender.state == UIGestureRecognizerStateCancelled) &#123; if (rootViewX &gt;= (UIScreen.mainScreen.bounds.size.width - self.spece)/2) &#123; [self lz_openSlderView]; &#125; else&#123; [self lz_closeSliderView]; &#125; &#125;&#125;#pragma mark - 打开侧边菜单- (void)lz_openSlderView &#123; [self lz_setupGusture]; UIView *rootView = self.mainController.view; UIView *menuView = self.sliderController.view; self.coverView.hidden = false; [UIView animateWithDuration:0.4 animations:^&#123; rootView.left = UIScreen.mainScreen.bounds.size.width - self.spece; menuView.right = rootView.left; self.coverView.frame = rootView.frame; self.coverView.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent:0.5]; &#125;];&#125;#pragma mark - 关闭侧边菜单- (void)lz_closeSliderView &#123; UIView *rootView = self.mainController.view; UIView *menuView = self.sliderController.view; [UIView animateWithDuration:0.4 animations:^&#123; self.coverView.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent:0]; rootView.left = 0; menuView.right = rootView.left; self.coverView.frame = rootView.frame; &#125; completion:^(BOOL finished) &#123; if (finished) &#123; self.coverView.hidden = true; &#125; &#125;];&#125;#pragma mark - 比较大小取最小值- (CGFloat)lz_minmumWithValueA:(CGFloat)a valueB:(CGFloat)b &#123; return a &gt; b ? b : a;&#125;#pragma mark - 比较大小取最大值- (CGFloat)lz_maxmumWithValueA:(CGFloat)a valueB:(CGFloat)b &#123; return a &gt; b ? a : b;&#125;#pragma mark - Setter- (void)setAllowOpenSliderView:(BOOL)allowOpenSliderView &#123; _allowOpenSliderView = allowOpenSliderView; if (allowOpenSliderView) &#123; [self lz_setupGusture]; &#125; else &#123; for (UIGestureRecognizer *pan in self.view.gestureRecognizers) &#123; [self.view removeGestureRecognizer:pan]; &#125; &#125;&#125;@end AppDelegate中设置为根控制器1self.window.rootViewController = [[LZSliderContainerViewController mamager] lz_setupMainController:tab sliderController:sldier space:200]; // 单独打开或关闭1234// 打开页面[[LZSliderContainerViewController mamager] lz_openSlderView];// 关闭页面[[LZSliderContainerViewController mamager] lz_closeSliderView]; 默认所有页面都是打开的，如果需要关闭123456789- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [LZSliderContainerViewController mamager].allowOpenSliderView = NO;&#125;- (void)viewDidDisappear:(BOOL)animated &#123; [super viewDidDisappear:animated]; [LZSliderContainerViewController mamager].allowOpenSliderView = true;&#125; 效果图]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据存储：FMDB-模型进行存取]]></title>
    <url>%2F2018%2F09%2F05%2F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%9AFMDB-%E6%A8%A1%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%AD%98%E5%8F%96%2F</url>
    <content type="text"><![CDATA[写这个Blog的目的是为了记录的学习经历，代码写的不是很好，希望读者理解。日常对数据库的操作，需要设计字段，感觉太繁琐了，想找个简化的方法，就想通过这样进行实现，这也就是一种思考方式。实际实现还是看需求。具体看代码：1、导入FMDB1import FMDB 2、使用单利模式和必要属性1234static let defaultManger = WDDataBaseManager()typealias successBlock = () -&gt;Voidtypealias failBlock = () -&gt;Voidprivate var tableName:String? 3、懒加载创建数据库（名称我随便取得）12345lazy var fmdb:FMDatabase = &#123; let path = NSHomeDirectory().appending("/Documents/testDB.db") let db = FMDatabase(path: path) return db &#125;() 4、创建表123456789func creatTable(tableName:String) -&gt; Void &#123; fmdb.open() self.tableName = tableName let creatSql = "create table if not exists \(tableName) (id integer primary key autoincrement,model BLOB)" let result = fmdb.executeUpdate(creatSql, withArgumentsIn:[]) if result&#123; print("创建表成功") &#125; &#125; 5、删除表1234567func dropTable() -&gt; Void &#123; let sql = "drop table if exists " + tableName! let result = fmdb.executeUpdate(sql, withArgumentsIn:[]) if result&#123; print("删除表成功") &#125; &#125; 6、插入数据1234567891011func insert(model:NSObject, successBlock: successBlock, failBlock: failBlock) -&gt; Void &#123; let modelData = try! NSKeyedArchiver.archivedData(withRootObject: model, requiringSecureCoding: false) let insertSql = "insert into " + tableName! + " (model) values(?)" do &#123; try fmdb.executeUpdate(insertSql, values: [modelData]) successBlock() &#125; catch &#123; print(fmdb.lastError()) failBlock() &#125; &#125; 7、更新表1234567891011func update(model:NSObject,uid:Int32, successBlock: successBlock, failBlock: failBlock) -&gt; Void &#123; let modelData = try! NSKeyedArchiver.archivedData(withRootObject: model, requiringSecureCoding: false) let updateSql = "update " + tableName! + " set model = ? where id = ?" do &#123; try fmdb.executeUpdate(updateSql, values: [modelData, uid]) successBlock() &#125; catch &#123; print(fmdb.lastError()) failBlock() &#125; &#125; 8、查询数据（这是查询所有数据，其他按需求设计）123456789101112131415161718func selectAll() -&gt; [NSObject] &#123; var tmpArr = [NSObject]() let selectSql = "select * from " + tableName! do &#123; let rs = try fmdb.executeQuery(selectSql, values:nil) while rs.next() &#123; var model = NSObject() let modelData = rs.data(forColumn:"model") let id = rs.int(forColumn: "id") model = try! NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(modelData!) as! NSObject model.wd_fmdb_id = id tmpArr.append(model) &#125; &#125; catch &#123; print(fmdb.lastError()) &#125; return tmpArr &#125; 9、删除数据（这是根据Id删除的）12345678910func delete(uid:Int32, successBlock: successBlock, failBlock: failBlock) -&gt; Void &#123; let deleteSql = "delete from " + tableName! + " where id = ?" do &#123; try fmdb.executeUpdate(deleteSql, values: [uid]) successBlock() &#125; catch &#123; print(fmdb.lastError()) failBlock() &#125; &#125; 10、新增分类添加默认Id1234567891011private var wd_id_key: String = "key"extension NSObject &#123; open var wd_fmdb_id:Int32? &#123; get &#123; return (objc_getAssociatedObject(self, &amp;wd_id_key) as? Int32) &#125; set(newValue) &#123; objc_setAssociatedObject(self, &amp;wd_id_key, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_ASSIGN) &#125; &#125;&#125; 11、使用方法12345678910111213141516171819202122232425//1. 在Appdelegate中打开数据库func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; DataBaseManager.defaultManger.creatTable() return true &#125;//2、添加数据WDDataBaseManager.defaultManger.insert(model: model, successBlock: &#123; print("成功") &#125;, failBlock: &#123; print("失败") &#125;)//3、修改数据WDDataBaseManager.defaultManger.update(model: model, uid: self.model!.wd_fmdb_id!, successBlock: &#123; print("成功") &#125;, failBlock: &#123; print("失败") &#125;)//4、删除数据WDDataBaseManager.defaultManger.delete(uid: model.wd_fmdb_id!, successBlock: &#123; print("成功") &#125;, failBlock: &#123; print("失败") &#125;)// 5、查询数据WDDataBaseManager.defaultManger.selectAll() 遵循NSCoding 重写三个方法12345678910111213141516171819202122232425import UIKitclass Model: NSObject , NSCoding&#123; public var name:String? public var phone:String? public var addres:String? override init() &#123; super.init() &#125; func encode(with aCoder: NSCoder) &#123; aCoder.encode(name, forKey: "name") aCoder.encode(phone, forKey: "phone") aCoder.encode(addres, forKey: "addres") &#125; required init?(coder aDecoder: NSCoder) &#123; super.init() self.name = aDecoder.decodeObject(forKey: "name") as? String self.addres = aDecoder.decodeObject(forKey: "addres") as? String self.phone = aDecoder.decodeObject(forKey: "phone") as? String &#125;&#125; 12、效果图 13、Demo地址:https://github.com/wudan-ios/FMDB-Model.git 补充Objective-C版本1、接口文件12345678910111213141516171819202122232425262728293031#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface NSObject (addId)@property (nonatomic) NSInteger wd_fmdb_id;@endtypedef void(^successBlock)(void);typedef void(^failBlock)(void);@interface WDDataBaseManager : NSObject+ (instancetype)manager;/** 创建表 */- (void)createTableWithName:(NSString *)name;/** 删除表 */- (void)dropTable;/** 添加数据 */- (void)insertDataWithModel:(NSObject *)model successBlock:(successBlock)aSuccessBlock failBlock:(failBlock)aFailBlock;/** 更新数据 */- (void)updateDataWithModel:(NSObject *)model uid:(NSInteger)aUid successBlock:(successBlock)aSuccessBlock failBlock:(failBlock)aFailBlock;/** 删除数据 */- (void)deleteDataWithUid:(NSInteger)uid successBlock:(successBlock)aSuccessBlock failBlock:(failBlock)aFailBlock;/** 查询全部数据 */- (NSArray&lt;NSObject *&gt; *)queryAllData;@endNS_ASSUME_NONNULL_END 2、实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#import "WDDataBaseManager.h"#import &lt;FMDB.h&gt;#import &lt;objc/runtime.h&gt;static char *wd_id_key = "key";@implementation NSObject (addId)- (NSInteger)wd_fmdb_id &#123; NSNumber *numberValue = objc_getAssociatedObject(self, wd_id_key); return numberValue.integerValue;&#125;- (void)setWd_fmdb_id:(NSInteger)wd_fmdb_id &#123; objc_setAssociatedObject(self, wd_id_key, @(wd_fmdb_id), OBJC_ASSOCIATION_ASSIGN);&#125;@end@interface WDDataBaseManager ()@property (nonatomic, strong) FMDatabase *fmdb;@property (nonatomic, copy) NSString *tableName;@end@implementation WDDataBaseManager+ (instancetype)manager &#123; static dispatch_once_t onceToken; static WDDataBaseManager *manager = nil; dispatch_once(&amp;onceToken, ^&#123; manager = [[WDDataBaseManager alloc] init]; &#125;); return manager;&#125;- (void)createTableWithName:(NSString *)name &#123; [self.fmdb open]; self.tableName = name; NSString *sql = [NSString stringWithFormat:@"create table if not exists %@ (id integer primary key autoincrement,model BLOB)", name]; BOOL result = [self.fmdb executeUpdate:sql]; if (result) &#123; NSLog(@"表创建成功"); &#125;&#125;- (void)dropTable &#123; NSString *sql = [NSString stringWithFormat:@"drop table if exists %@", self.tableName]; BOOL result = [self.fmdb executeUpdate:sql]; if (result) &#123; NSLog(@"表删除成功"); &#125;&#125;- (void)insertDataWithModel:(NSObject *)model successBlock:(successBlock)aSuccessBlock failBlock:(failBlock)aFailBlock &#123; NSData *modelData = [NSKeyedArchiver archivedDataWithRootObject:model]; NSString *sql = [NSString stringWithFormat:@"insert into %@ (model) values(?)", self.tableName]; BOOL result = [self.fmdb executeUpdate:sql withArgumentsInArray:@[modelData]]; if (result) &#123; aSuccessBlock(); &#125; else &#123; aFailBlock(); &#125;&#125;- (void)updateDataWithModel:(NSObject *)model uid:(NSInteger)aUid successBlock:(successBlock)aSuccessBlock failBlock:(failBlock)aFailBlock &#123; NSData *modelData = [NSKeyedArchiver archivedDataWithRootObject:model]; NSString *sql = [NSString stringWithFormat:@"update %@ set model = ? where id = ?", self.tableName]; BOOL result = [self.fmdb executeUpdate:sql withArgumentsInArray:@[modelData, @(aUid)]]; if (result) &#123; aSuccessBlock(); &#125; else &#123; aFailBlock(); &#125;&#125;- (void)deleteDataWithUid:(NSInteger)uid successBlock:(successBlock)aSuccessBlock failBlock:(failBlock)aFailBlock &#123; NSString *sql = [NSString stringWithFormat:@"delete from %@ where id = ?", self.tableName]; BOOL result = [self.fmdb executeUpdate:sql withArgumentsInArray:@[@(uid)]]; if (result) &#123; aSuccessBlock(); &#125; else &#123; aFailBlock(); &#125;&#125;- (NSArray&lt;NSObject *&gt; *)queryAllData &#123; NSMutableArray *array = [NSMutableArray array]; NSString *sql = [NSString stringWithFormat:@"select * from %@",self.tableName]; @try &#123; FMResultSet *rs = [self.fmdb executeQuery:sql]; while (rs.next) &#123; NSObject *model = [[NSObject alloc] init]; NSData *modelData = [rs dataForColumn:@"model"]; int uid = [rs intForColumn:@"id"]; model = [NSKeyedUnarchiver unarchiveObjectWithData:modelData]; model.wd_fmdb_id = uid; [array addObject:model]; &#125; &#125; @catch (NSException *exception) &#123; NSLog(@"%@", self.fmdb.lastError); &#125; @finally &#123; NSLog(@"查询数据"); &#125; return array;&#125;- (FMDatabase *)fmdb &#123; if (!_fmdb) &#123; NSString *path = [NSHomeDirectory() stringByAppendingString:@"/Documents/testDB.db"]; _fmdb = [[FMDatabase alloc] initWithPath:path]; &#125; return _fmdb;&#125;@end 3、使用方法1234567891011121314151617181920212223242526272829// 1、打开数据库，并创建表- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [[WDDataBaseManager manager] createTableWithName:@"test"]; return YES;&#125;// 2、添加数据 [[WDDataBaseManager manager] insertDataWithModel:model successBlock:^&#123; // TODO: &#125; failBlock:^&#123; // TODO: &#125;];// 3、查询数据[[WDDataBaseManager manager] queryAllData]// 4、修改数据[[WDDataBaseManager manager] updateDataWithModel:model uid:self.model.wd_fmdb_id successBlock:^&#123; // TODO: &#125; failBlock:^&#123; // TODO: &#125;];// 5、删除数据[[WDDataBaseManager manager] deleteDataWithUid:model.wd_fmdb_id successBlock:^&#123; // TODO: &#125; failBlock:^&#123; // TODO: &#125;];// 6、删除表[[WDDataBaseManager manager] dropTable]; 插入表中的Model需要遵循(实例代码)1234567891011121314- (void)encodeWithCoder:(nonnull NSCoder *)aCoder &#123; [aCoder encodeObject:self.name forKey:@"name"]; [aCoder encodeObject:self.phone forKey:@"phone"]; [aCoder encodeObject:self.address forKey:@"address"];&#125;- (nullable instancetype)initWithCoder:(nonnull NSCoder *)aDecoder &#123; if (self == [super init]) &#123; self.name = [aDecoder decodeObjectForKey:@"name"] ; self.phone = [aDecoder decodeObjectForKey:@"phone"]; self.address = [aDecoder decodeObjectForKey:@"address"]; &#125; return self;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据存储：CoreData]]></title>
    <url>%2F2018%2F09%2F01%2F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%9ACoreData%2F</url>
    <content type="text"><![CDATA[CoreData的简单使用介绍（已User表为例）重点类 NSManagedObject 通过Core Data从数据库中取出的对象,默认情况下都是NSManagedObject对象. NSManagedObject的工作模式有点类似于NSDictionary对象,通过键-值对来存取所有的实体属性. setValue:forkey:存储属性值(属性名为key); valueForKey:获取属性值(属性名为key). 每个NSManagedObject都知道自己属于哪个NSManagedObjectContext NSManagedObjectContext：管理对象上下文 负责数据和应用库之间的交互(CRUD，即增删改查、保存等接口都在这个对象中). 所有的NSManagedObject都存在于NSManagedObjectContext中，所以对象和context是相关联的 每个 context 和其他 context 都是完全独立的 每个NSManagedObjectContext都知道自己管理着哪些NSManagedObject NSManagedObjectModel：模型对象 Core Data的模型文件 NSPersistentStoreCoordinator：存储调度器 添加持久化存储库，CoreData的存储类型（比如SQLite数据库就是其中一种） 中间审查者，用来将对象图管理部分和持久化部分捆绑在一起，负责相互之间的交流（中介一样） NSEntityDescription： 用来描述实体：相当于数据库表中一组数据描述 User中字段1234@property (nonatomic) int16_t age;@property (nonatomic) int64_t id;@property (nullable, nonatomic, copy) NSString *name;@property (nonatomic) BOOL sex; 系统库1#import &lt;CoreData/CoreData.h&gt; 打开数据库123456789101112131415161718192021222324252627// 创建数据库 // 1. 实例化数据模型(将所有定义的模型都加载进来) // merge——合并 self.managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil]; // 2. 实例化持久化存储调度，要建立起桥梁，需要模型 self.persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:self.managedObjectModel]; // 3. 添加一个持久化的数据库到存储调度 // 3.1 建立数据库保存在沙盒的URL NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject; NSString *filePath = [[path stringByAppendingString:@"/"] stringByAppendingString:@"wudan.sqlite"]; NSURL *pathUrl = [NSURL fileURLWithPath:filePath]; // 3.2 打开或者新建数据库文件 // 如果文件不存在，则新建之后打开 // 否者直接打开数据库 NSError *error; @try &#123; [self.persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:pathUrl options:nil error:&amp;error]; self.context = [[NSManagedObjectContext alloc] init]; self.context.persistentStoreCoordinator = self.persistentStoreCoordinator; &#125; @catch (NSException *exception) &#123; NSLog(@"Error:%@",error); &#125; @finally &#123; NSLog(@"打开数据库"); &#125; 查询数据 全部查询12345678910111213141516- (void)queryAllResult:(void(^)(NSArray *dataArray))result &#123; NSMutableArray *array = [NSMutableArray array]; NSPredicate *predicate = [NSPredicate predicateWithFormat:@"id &gt; 0"]; NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"User"]; request.predicate = predicate; NSError *error; NSArray *re = [self.context executeFetchRequest:request error:&amp;error]; if (re.count != 0) &#123; for (User *user in re) &#123; [array addObject:user]; &#125; &#125; result(array);&#125; 分页查询123456789101112131415161718- (void)queryUserInfoWithPageNo:(NSInteger)pageNo pageSize:(NSInteger)pageSize result:(void(^)(NSArray *dataArray))result &#123; NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"User"]; NSSortDescriptor *scoreSort = [NSSortDescriptor sortDescriptorWithKey:@"id" ascending:true]; request.sortDescriptors = @[scoreSort]; request.fetchOffset = (pageNo - 1) * pageSize; request.fetchLimit = pageSize; NSError *error = nil; NSArray *re = [self.context executeFetchRequest:request error:&amp;error]; NSMutableArray *array = [NSMutableArray array]; if (re.count != 0) &#123; for (User *user in re) &#123; [array addObject:user]; &#125; &#125; result(array);&#125; 条件查询12345678910111213141516- (void)queryUserInfoByObject:(id)object value:(id)value result:(void(^)(NSArray *dataArray))result &#123; NSMutableArray *array = [NSMutableArray array]; NSPredicate *predicate = [NSPredicate predicateWithFormat:[NSString stringWithFormat:@"%@ = '%@'", object, value]]; NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"User"]; request.predicate = predicate; NSError *error; NSArray *re = [self.context executeFetchRequest:request error:&amp;error]; if (re.count != 0) &#123; for (User *user in re) &#123; [array addObject:user]; &#125; &#125; result(array);&#125; 新增数据123456789101112131415161718192021222324252627282930- (void)addUserInfo:(NSInteger)userId name:(NSString *)name sex:(BOOL)sex age:(NSInteger)age success:(void(^)(void))success fail:(void(^)(void))fail &#123; __block NSArray *array; [self queryUserInfoByObject:@"id" value:@(userId) result:^(NSArray * _Nonnull dataArray) &#123; array = dataArray; &#125;]; if (array.count == 0) &#123; User *user = [NSEntityDescription insertNewObjectForEntityForName:@"User" inManagedObjectContext:self.context]; user.name = name; user.id = userId; user.sex = sex; user.age = age; NSError *error; @try &#123; [self.context save:&amp;error]; success(); &#125; @catch (NSException *exception) &#123; NSLog(@"%@", error); fail(); &#125; @finally &#123; NSLog(@"新增"); &#125; &#125; else &#123; fail(); &#125;&#125; 更新数据123456789101112131415161718192021222324252627- (void)updateUserInfo:(NSInteger)userId infoDic:(NSDictionary *)dic success:(void(^)(void))success fail:(void(^)(void))fail &#123; NSPredicate *predicate = [NSPredicate predicateWithFormat:[NSString stringWithFormat:@"id = %ld", userId]]; NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"User"]; request.predicate = predicate; NSError *error; if (dic.count &gt; 0) &#123; NSArray *re = [self.context executeFetchRequest:request error:&amp;error]; if (re.count &gt; 0) &#123; for (User *user in re) &#123; [dic enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; [user setValue:obj forKey:key]; &#125;]; &#125; &#125; @try &#123; [self.context save:&amp;error]; success(); &#125; @catch (NSException *exception) &#123; NSLog(@"%@", error); fail(); &#125; @finally &#123; NSLog(@"更新"); &#125; &#125;&#125; 删除数据1234567891011121314151617181920212223- (void)deleteUserInfo:(NSInteger)userId success:(void(^)(void))success fail:(void(^)(void))fail &#123; NSPredicate *predicate = [NSPredicate predicateWithFormat:[NSString stringWithFormat:@"id = %ld", userId]]; NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"User"]; request.predicate = predicate; NSError *error; NSArray *re = [self.context executeFetchRequest:request error:&amp;error]; if (re.count &gt; 0) &#123; @try &#123; [self.context deleteObject:re.firstObject]; [self.context save:nil]; success(); &#125; @catch (NSException *exception) &#123; NSLog(@"%@", error); fail(); &#125; @finally &#123; NSLog(@"删除数据"); &#125; &#125; else &#123; NSLog(@"数据库中暂无该数据"); fail(); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS自定义控件：分段选择器-Swift]]></title>
    <url>%2F2018%2F08%2F29%2FiOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%9A%E5%88%86%E6%AE%B5%E9%80%89%E6%8B%A9%E5%99%A8-Swift%2F</url>
    <content type="text"><![CDATA[废话不多说，直接上代码 1、数据源方法12345678910111213141516171819// MARK: ============ SegmentSelectorManagerDataSource ============@objc protocol SegmentSelectorManagerDataSource:NSObjectProtocol &#123; /// 主要配置 -&gt; 必须要实现 func nameOfSliderItems(segemntControl:SegmentSelectorManager) -&gt; Array&lt;String&gt; func childViewControllers(segemntControl:SegmentSelectorManager) -&gt; Array&lt;UIViewController&gt; /// 字体颜色配置 -&gt; 有默认 @objc optional func colorOfSlider(segemntControl:SegmentSelectorManager) -&gt; UIColor @objc optional func colorOfTopView(segemntControl:SegmentSelectorManager) -&gt; UIColor /// 背景颜色配置 -&gt; 有默认 @objc optional func colorOfSliderItemsTitle(segemntControl:SegmentSelectorManager) -&gt; UIColor @objc optional func colorOfHighlightedSliderItemsTitle(segemntControl:SegmentSelectorManager) -&gt; UIColor /// 高度配置 -&gt; 有默认 @objc optional func heightOfTopView(segemntControl:SegmentSelectorManager) -&gt; CGFloat @objc optional func heightOfSlider(segemntControl:SegmentSelectorManager) -&gt; CGFloat&#125; 2、代理方法1234// MARK: ============ SegmentSelectorManagerDelegate ============protocol SegmentSelectorManagerDelegate &#123; func slideView(sliderView:SegmentSelectorManager, didSelectItemAtIndex:Int) -&gt; Void&#125; 3、页面实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596override init(frame: CGRect) &#123; super.init(frame: frame) &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError("init(coder:) has not been implemented") &#125; /// 数据源 public weak var dataSource:SegmentSelectorManagerDataSource? &#123; didSet &#123; // 名称数组 namesOfSlideItems = dataSource?.nameOfSliderItems(segemntControl: self) // 控制器数组 childControllersArray = dataSource?.childViewControllers(segemntControl: self) if let ds = dataSource &#123; if (ds.responds(to: #selector(ds.colorOfHighlightedSliderItemsTitle(segemntControl:)))) &#123; //按钮字体颜色默认 colorOfSlideItemsTitle = ds.colorOfSliderItemsTitle!(segemntControl: self) &#125; if (ds.responds(to: #selector(ds.colorOfHighlightedSliderItemsTitle(segemntControl:)))) &#123; // 按钮字体颜色选中 colorOfHighlightedSlideItemsTitle = ds.colorOfHighlightedSliderItemsTitle!(segemntControl: self) &#125; if (ds.responds(to: #selector(ds.colorOfSlider(segemntControl:)))) &#123; // 指示器颜色 colorOfSlider = ds.colorOfSlider!(segemntControl: self) &#125; if ds.responds(to: #selector(ds.heightOfTopView(segemntControl:))) &#123; // 顶部视图高度 heightOfTopView = (ds.heightOfTopView!(segemntControl: self)) &#125; if ds.responds(to: #selector(ds.heightOfTopView(segemntControl:))) &#123; // 指示器高度 heightOfSlider = (ds.heightOfSlider!(segemntControl: self)) &#125; &#125; &#125; &#125; // 代理 public var delegate:SegmentSelectorManagerDelegate? var namesOfSlideItems: Array&lt;String&gt;? = [] // 名称数组 var colorOfSlider: UIColor? = UIColor.orange // 指示器颜色 var colorOfSlideView: UIColor? = UIColor.white // 顶部视图颜色 var colorOfSlideItemsTitle: UIColor? = UIColor.gray // 默认字体颜色 var colorOfHighlightedSlideItemsTitle: UIColor? = UIColor.orange // 选中字体颜色 var heightOfTopView:CGFloat = 45 // 顶部视图高度 var heightOfSlider:CGFloat = 2 // 指示器高度 let SliderThanSliderView_WidthRatio:CGFloat = 1 // 按钮和指示器宽度比 var buttonsArray:Array&lt;UIButton&gt;? = [] // 所有按钮的数组 var childControllersArray:Array&lt;UIViewController&gt;? = [] // 控制器数组 let SCREEN_WIDTH = UIScreen.main.bounds.size.width let SCREEN_HEIGHT = UIScreen.main.bounds.height /// 顶部View lazy var slideBar:UIView = &#123; let view = UIView.init() view.backgroundColor = colorOfSlideView addSubview(view) view.translatesAutoresizingMaskIntoConstraints = false view.leadingAnchor.constraint(equalTo: leadingAnchor).isActive = true view.trailingAnchor.constraint(equalTo: trailingAnchor).isActive = true view.topAnchor.constraint(equalTo: topAnchor).isActive = true view.heightAnchor.constraint(equalToConstant: self.heightOfTopView).isActive = true return view &#125;() // 底部指示器 var slider:UIView? /// 控制器ScrollView lazy var contentScrollView:UIScrollView = &#123; let sc = UIScrollView.init() sc.isDirectionalLockEnabled = true sc.backgroundColor = UIColor.white sc.isPagingEnabled = true sc.showsHorizontalScrollIndicator = false sc.delegate = self sc.bounces = false addSubview(sc) sc.translatesAutoresizingMaskIntoConstraints = false sc.leadingAnchor.constraint(equalTo: leadingAnchor).isActive = true sc.trailingAnchor.constraint(equalTo: trailingAnchor).isActive = true sc.topAnchor.constraint(equalTo: self.slideBar.bottomAnchor).isActive = true sc.bottomAnchor.constraint(equalTo: bottomAnchor).isActive = true return sc &#125;() #####4、绘制页面UI123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124 // 获取当前页面的控制器 public func viewController()-&gt;UIViewController? &#123; var nextResponder: UIResponder? = self repeat &#123; nextResponder = nextResponder?.next if let viewController = nextResponder as? UIViewController &#123; return viewController &#125; &#125; while nextResponder != nil return nil &#125;override func layoutSubviews() &#123; super.layoutSubviews() addSlider() addButton() addContentScrollView() &#125;/// 添加按钮到顶部视图 func addButton() &#123; let numberOfItems:Int = (namesOfSlideItems?.count)! let slideItemWidth = SCREEN_WIDTH / CGFloat(numberOfItems) let sliderWidth = slideItemWidth * SliderThanSliderView_WidthRatio let position_x = (slideItemWidth - sliderWidth) / 2.0 for index in 0..&lt;numberOfItems &#123; let b = UIButton.init(type: .custom) b.tag = index b.setTitle(namesOfSlideItems![index], for: .normal) b.setTitleColor(colorOfSlideItemsTitle, for: .normal) b.titleLabel?.textAlignment = .center b.addTarget(self, action: #selector(buttonTouched(button:)), for: .touchUpInside) buttonsArray?.append(b) b.frame = CGRect(x: position_x + slideItemWidth * CGFloat(index), y: 5, width: sliderWidth, height: heightOfTopView-5) slideBar.addSubview(b) if index == 0 &#123; b.setTitleColor(colorOfHighlightedSlideItemsTitle!, for: .normal) &#125; &#125; &#125; // 添加底部指示器到顶部视图 func addSlider() &#123; let slideItemWidth = SCREEN_WIDTH / CGFloat((namesOfSlideItems?.count)!) let sliderWidth = slideItemWidth * SliderThanSliderView_WidthRatio let position_x = (slideItemWidth - sliderWidth) / 2.0 slideBar.addSubview(sliderView(frame: CGRect(x: position_x, y: heightOfTopView - heightOfSlider, width: sliderWidth, height: heightOfSlider))) slideBar.backgroundColor = colorOfSlideView slider?.backgroundColor = colorOfSlider &#125; // 添加ScrollView func addContentScrollView() &#123; contentScrollView.contentSize = CGSize(width: SCREEN_WIDTH * CGFloat((namesOfSlideItems?.count)!), height: 0) for (index) in (childControllersArray?.enumerated())! &#123; index.element.view.frame = CGRect(x: CGFloat(index.offset) * SCREEN_WIDTH, y: 0, width: contentScrollView.frame.width, height: contentScrollView.frame.height) contentScrollView.addSubview(index.element.view) viewController()?.addChild(index.element) index.element.didMove(toParent: viewController()) &#125; &#125; // vc滚动动画 func animateSlider(tag:Int) -&gt; Void &#123; contentScrollView.setContentOffset(CGPoint(x: SCREEN_WIDTH * CGFloat(tag), y: 0), animated: true) &#125; // 指示器滚动动画 func animateSliderToPosition(offset:CGPoint) -&gt; Void &#123; let slideItemWidth = SCREEN_WIDTH / CGFloat((namesOfSlideItems?.count)!) let sliderWidth = slideItemWidth * SliderThanSliderView_WidthRatio let position_x = (slideItemWidth - sliderWidth) / 2.0 let newFrame = CGRect(x: (offset.x / SCREEN_WIDTH) * slideItemWidth + position_x, y: (slider?.frame.origin.y)!, width: (slider?.frame.width)!, height: (slider?.frame.height)!) slider?.frame = newFrame for (index) in (buttonsArray?.enumerated())! &#123; index.element.setTitleColor(colorOfSlideItemsTitle, for: .normal) &#125; var buttonTag = 0 let ratio = offset.x / SCREEN_WIDTH let tempRation = Int(ratio) let decimal:CGFloat = ratio - CGFloat(tempRation) if decimal &gt;= 0.5 &#123; buttonTag = Int(ratio) + 1 &#125; else &#123; buttonTag = Int(ratio) &#125; buttonsArray![buttonTag].setTitleColor(colorOfHighlightedSlideItemsTitle, for: .normal) &#125; /// 根据frame初始化指示器 func sliderView(frame:CGRect) -&gt; UIView &#123; slider = UIView.init(frame: frame) return slider! &#125; /// 点击事件 @objc func buttonTouched(button:UIButton) &#123; delegate?.slideView(sliderView: self, didSelectItemAtIndex: button.tag) animateSlider(tag: tag) contentScrollView.setContentOffset(CGPoint(x: SCREEN_WIDTH * CGFloat(button.tag), y: 0), animated: true) &#125; 5、使用Extension实现UIScrollViewDidScrollDelegate123456// MARK: ============ UIScrollViewDidScrollDelegate ============extension SegmentSelectorManager:UIScrollViewDelegate &#123; func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; animateSliderToPosition(offset: scrollView.contentOffset) &#125;&#125; 6、使用方法(实例代码)12345678910111213141516override func setupSubViewsProperties() &#123; segmentView = SegmentSelectorManager.init(frame: CGRect.zero) segmentView?.delegate = self segmentView?.dataSource = self view.addSubview(segmentView!) &#125; override func setupSubViewsConstrains() &#123; if let seg = segmentView &#123; seg.translatesAutoresizingMaskIntoConstraints = false seg.leadingAnchor.constraint(equalTo: view.leadingAnchor).isActive = true seg.trailingAnchor.constraint(equalTo: view.trailingAnchor).isActive = true seg.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -kTabBarHeight).isActive = true seg.topAnchor.constraint(equalTo: wd_navgationBar_normal.bottomAnchor).isActive = true &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940extension HotPlayController: SegmentSelectorManagerDataSource &#123; func nameOfSliderItems(segemntControl: SegmentSelectorManager) -&gt; Array&lt;String&gt; &#123; return ["正在热映", "即将上映"] &#125; func childViewControllers(segemntControl: SegmentSelectorManager) -&gt; Array&lt;UIViewController&gt; &#123; return [HotPlayingController(), HotWillPlayViewController()] &#125; func heightOfTopView(segemntControl: SegmentSelectorManager) -&gt; CGFloat &#123; return 45 &#125; func heightOfSlider(segemntControl: SegmentSelectorManager) -&gt; CGFloat &#123; return 3 &#125; func colorOfSlider(segemntControl slider: SegmentSelectorManager) -&gt; UIColor &#123; return UIColor.wd_init(r: 73, g: 73, b: 73) &#125; func colorOfTopView(segemntControl: SegmentSelectorManager) -&gt; UIColor &#123; return UIColor.white &#125; func colorOfSliderItemsTitle(segemntControl: SegmentSelectorManager) -&gt; UIColor &#123; return UIColor.gray &#125; func colorOfHighlightedSliderItemsTitle(segemntControl: SegmentSelectorManager) -&gt; UIColor &#123; return UIColor.wd_init(r: 73, g: 73, b: 73) &#125;&#125;extension HotPlayController: SegmentSelectorManagerDelegate &#123; func slideView(sliderView: SegmentSelectorManager, didSelectItemAtIndex: Int) &#123; &#125;&#125; 7、效果图]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据存储：KeyChain]]></title>
    <url>%2F2018%2F08%2F20%2F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%9AKeyChain%2F</url>
    <content type="text"><![CDATA[KeyChain是利用系统钥匙串进行简单的信息存取。类似于UserDefault; 接口文件 123456789101112131415161718192021222324252627282930313233#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface LZKeyChainManager : NSObject+ (instancetype)manager;/** 写入数据 @param service 名称 @param data 数据 */- (void)save:(NSString *)service data:(id)data;/** 查询数据 @param service s名称 @return return value description */- (id)load:(NSString *)service;/** 删除 @param service 名称 */- (void)deleteInfo:(NSString *)service;@endNS_ASSUME_NONNULL_END 实现文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#import "LZKeyChainManager.h"@implementation LZKeyChainManager+ (instancetype)manager &#123; static dispatch_once_t onceToken; static LZKeyChainManager *manager; dispatch_once(&amp;onceToken, ^&#123; manager = [[LZKeyChainManager alloc] init]; &#125;); return manager;&#125;- (NSMutableDictionary *)getKeychainQuery:(NSString *)service &#123; return [NSMutableDictionary dictionaryWithObjectsAndKeys:(id)kSecClassGenericPassword,(id)kSecClass, service, (id)kSecAttrService, service, (id)kSecAttrAccount, (id)kSecAttrAccessibleAfterFirstUnlock,(id)kSecAttrAccessible, nil]; &#125;#pragma mark - 写入- (void)save:(NSString *)service data:(id)data &#123; NSMutableDictionary *keychainQuery = [self getKeychainQuery:service]; SecItemDelete((CFDictionaryRef)keychainQuery); [keychainQuery setObject:[NSKeyedArchiver archivedDataWithRootObject:data] forKey:(id)kSecValueData]; SecItemAdd((CFDictionaryRef)keychainQuery, NULL);&#125;#pragma mark - 读取- (id)load:(NSString *)service &#123; id ret = nil; NSMutableDictionary *keychainQuery = [self getKeychainQuery:service]; [keychainQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData]; [keychainQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit]; CFDataRef keyData = NULL; if (SecItemCopyMatching((CFDictionaryRef)keychainQuery, (CFTypeRef *)&amp;keyData) == noErr) &#123; @try &#123; ret = [NSKeyedUnarchiver unarchiveObjectWithData:(__bridge NSData *)keyData]; &#125; @catch (NSException *e) &#123; NSLog(@"Unarchive of %@ failed: %@", service, e); &#125; @finally &#123; &#125; &#125; if (keyData) CFRelease(keyData); return ret;&#125;#pragma mark - 删除- (void)deleteInfo:(NSString *)service &#123; NSMutableDictionary *keychainQuery = [self getKeychainQuery:service]; SecItemDelete((CFDictionaryRef)keychainQuery);&#125;@end]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS自定义控件：一个简易的Combobox]]></title>
    <url>%2F2018%2F08%2F18%2FiOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84Combobox%2F</url>
    <content type="text"><![CDATA[代码简单易懂，属于自己练手的代码，还在学习，写的不好，希望勿喷1、头文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGINtypedef NS_ENUM(NSInteger, WDComboBoxControlDirection) &#123; WDComboBoxControlDirectionTop, WDComboBoxControlDirectionLeading, WDComboBoxControlDirectionTrailing, WDComboBoxControlDirectionBottom,&#125;;@protocol WDComboBoxControlDataSource &lt;NSObject&gt;@optional/** &lt; 数据数组 &gt; */- (NSArray&lt;NSArray&lt;NSString *&gt; *&gt; *)dataSourceOfColunm;@required/** &lt; 标题数组 &gt; */- (NSArray&lt;NSString *&gt; *)titleOfSection;@end@protocol WDComboBoxControlDelegate &lt;NSObject&gt;/** 点击事件 @param indexPath indexPath description @param title title description @param sourceView sourceView description */- (void)selectedAtIndexPath:(NSIndexPath *)indexPath resultTitle:(NSString *)title fromSourceView:(UIView *)sourceView;@end@interface WDComboBoxControl : UIView@property (nonatomic, weak) id &lt;WDComboBoxControlDataSource&gt; dataSource;@property (nonatomic, weak) id &lt;WDComboBoxControlDelegate&gt; delegate;/** &lt; 背景按钮，可以定义需要的属性 &gt; */@property (nonatomic, strong) UIButton *backgroundButton;/** &lt; 内容TableView，也可以定义一些属性 &gt; */@property (nonatomic, strong) UITableView *tableView;/** 初始化方法 @param height 显示内容高度 @param view 参考View @return return value description */- (instancetype)initViewWithMaxHeight:(CGFloat)height fromView:(UIView *)view showDirection:(WDComboBoxControlDirection)direction;/** 显示页面 */- (void)showInView;@endNS_ASSUME_NONNULL_END 2、实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#import "WDComboBoxControl.h"@interface WDComboBoxControl () &lt;UITableViewDelegate, UITableViewDataSource&gt;@property (nonatomic, assign) CGFloat viewHeight;@property (nonatomic, strong) NSArray&lt;NSArray&lt;NSString *&gt; *&gt; * dataArray;@property (nonatomic, strong) NSArray&lt;NSString *&gt; * titleArray;@property (nonatomic, strong) UIView *sourceView;@property (nonatomic, assign) WDComboBoxControlDirection direction;@end@implementation WDComboBoxControl#pragma mark =============== 初始化页面 ===============- (instancetype)initViewWithMaxHeight:(CGFloat)height fromView:(UIView *)view showDirection:(WDComboBoxControlDirection)direction &#123; self = [super init]; if (self) &#123; _viewHeight = height; _sourceView = view; _direction = direction; [self setupSubViewsPropertys]; [self setupSubViewsConstraints]; &#125; return self;&#125;#pragma mark =============== 显示页面 ===============- (void)showInView &#123; self.frame = UIScreen.mainScreen.bounds; [UIApplication.sharedApplication.delegate.window addSubview:self];&#125;#pragma mark =============== 让页面消失 ===============- (void)dismisssView &#123; [self removeFromSuperview];&#125;#pragma mark =============== 获取数据源 ===============- (void)setDataSource:(id&lt;WDComboBoxControlDataSource&gt;)dataSource &#123; _dataSource = dataSource; if (self.dataSource &amp;&amp; [self.dataSource respondsToSelector:@selector(dataSourceOfColunm)]) &#123; self.dataArray = [self.dataSource dataSourceOfColunm]; &#125; if (self.dataArray &amp;&amp; [self.dataSource respondsToSelector:@selector(titleOfSection)]) &#123; self.titleArray = [self.dataSource titleOfSection]; &#125; [self.tableView reloadData];&#125;#pragma mark =============== Add controls, set properties ===============- (void)setupSubViewsPropertys &#123; self.backgroundButton = [[UIButton alloc] init]; self.backgroundButton.backgroundColor = UIColor.clearColor; [self.backgroundButton addTarget:self action:@selector(dismisssView) forControlEvents:UIControlEventTouchUpInside]; [self addSubview:self.backgroundButton]; self.tableView = [[UITableView alloc] init]; self.tableView.delegate = self; self.tableView.dataSource = self; self.tableView.tableFooterView = [[UIView alloc] init]; self.tableView.layer.borderColor = UIColor.lightGrayColor.CGColor; self.tableView.layer.borderWidth = 0.5; self.tableView.estimatedRowHeight = 45; self.tableView.layer.cornerRadius = 5; self.tableView.rowHeight = UITableViewAutomaticDimension; [self addSubview:self.tableView];&#125;#pragma mark =============== Setting control layout constraints ===============- (void)setupSubViewsConstraints &#123; self.backgroundButton.frame = UIScreen.mainScreen.bounds; switch (self.direction) &#123; case WDComboBoxControlDirectionBottom:&#123; self.tableView.frame = CGRectMake(CGRectGetMinX(self.sourceView.frame), CGRectGetMaxY(self.sourceView.frame), self.sourceView.frame.size.width, self.viewHeight); &#125; break; case WDComboBoxControlDirectionTop:&#123; self.tableView.frame = CGRectMake(CGRectGetMinX(self.sourceView.frame), CGRectGetMaxY(self.sourceView.frame) - self.viewHeight - self.sourceView.frame.size.height, self.sourceView.frame.size.width, self.viewHeight); &#125; break; case WDComboBoxControlDirectionLeading:&#123; self.tableView.frame = CGRectMake(CGRectGetMinX(self.sourceView.frame) - self.sourceView.frame.size.width, CGRectGetMinY(self.sourceView.frame), self.sourceView.frame.size.width, self.viewHeight); &#125; break; case WDComboBoxControlDirectionTrailing:&#123; self.tableView.frame = CGRectMake(CGRectGetMinX(self.sourceView.frame) + self.sourceView.frame.size.width, CGRectGetMinY(self.sourceView.frame), self.sourceView.frame.size.width, self.viewHeight); &#125; break; default: break; &#125; &#125;#pragma mark =============== UITableViewDelegate, UITableViewDataSource ===============- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section &#123; return self.titleArray[section];&#125;- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123; return self.dataArray.count;&#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return [self.dataArray[section] count];&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"]; if (!cell) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"cell"]; &#125; cell.textLabel.text = self.dataArray[indexPath.section][indexPath.row]; cell.textLabel.numberOfLines = 0; return cell;&#125;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(selectedAtIndexPath:resultTitle: fromSourceView:)]) &#123; [self.delegate selectedAtIndexPath:indexPath resultTitle:self.dataArray[indexPath.section][indexPath.row] fromSourceView:self.sourceView]; [self dismisssView]; &#125;&#125;@end 3、使用方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 1、导入头文件#import "WDComboBoxControl.h"// 2、遵循代理和数据源&lt;WDComboBoxControlDataSource, WDComboBoxControlDelegate&gt;// 3、实现方法#pragma mark =============== WDComBoxControlDataSource ===============- (NSArray&lt;NSString *&gt; *)titleOfSection;- (NSArray&lt;NSArray&lt;NSString *&gt; *&gt; *)dataSourceOfColunm;#pragma mark =============== WDComBoxControlDelegate ===============- (void)selectedAtIndexPath:(NSIndexPath *)indexPath resultTitle:(NSString *)title fromSourceView:(UIView *)sourceView;// 下面是实例：@property (nonatomic, strong) UIButton *button;@property (nonatomic, strong) UIButton *button2;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. UIButton *button = [[UIButton alloc] init]; [button setTitleColor:UIColor.blackColor forState:UIControlStateNormal]; [button addTarget:self action:@selector(buttonShow:) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:button]; button.layer.borderColor = UIColor.lightGrayColor.CGColor; button.layer.borderWidth = 0.5; [button setTitle:@"按钮" forState:UIControlStateNormal]; [button mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerX.mas_equalTo(self.view); make.top.mas_equalTo(self.wdNavigationBar.mas_bottom); make.width.mas_equalTo(300); &#125;]; self.button = button; UIButton *button2 = [[UIButton alloc] init]; [button2 setTitleColor:UIColor.blackColor forState:UIControlStateNormal]; [button2 addTarget:self action:@selector(buttonShow:) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:button2]; button2.layer.borderColor = UIColor.lightGrayColor.CGColor; button2.layer.borderWidth = 0.5; [button2 setTitle:@"按钮2" forState:UIControlStateNormal]; button2.bounds = CGRectMake(0, 0, 300, 50); button2.center = self.view.center; self.button2 = button2;&#125;- (void)buttonShow:(UIButton *)sender &#123; WDComboBoxControl *view = [[WDComboBoxControl alloc] initViewWithMaxHeight:400 fromView:sender showDirection:WDComboBoxControlDirectionBottom]; view.dataSource = self; view.delegate = self; view.backgroundButton.backgroundColor = [UIColor colorWithWhite:0 alpha:0.3]; [view showInView];&#125;#pragma mark =============== WDComBoxControlDataSource ===============- (NSArray&lt;NSString *&gt; *)titleOfSection &#123; return @[@"安徽省", @"浙江省", @"江苏省", @"安徽省", @"浙江省", @"江苏省"];&#125;- (NSArray&lt;NSArray&lt;NSString *&gt; *&gt; *)dataSourceOfColunm &#123; return @[@[@"合肥", @"芜湖", @"安庆"], @[@"南京", @"苏州", @"无锡"], @[@"杭州", @"宁波", @"温州"], @[@"合肥", @"芜湖", @"安庆"], @[@"南京", @"苏州", @"无锡"], @[@"杭州", @"宁波", @"温州"]];&#125;#pragma mark =============== WDComBoxControlDelegate ===============- (void)selectedAtIndexPath:(NSIndexPath *)indexPath resultTitle:(NSString *)title fromSourceView:(UIView *)sourceView &#123; UIButton *sender = (UIButton *)sourceView; [sender setTitle:title forState:UIControlStateNormal];&#125; 4、效果图 5、Demo地址（代码都在这里了，就不弄个Demo了，这个可以自定义的地方还有很多，TableView和背景的Button都可以，随心所欲吧！）]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据存储：归档、解档]]></title>
    <url>%2F2018%2F08%2F15%2F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%9A%E5%BD%92%E6%A1%A3%E3%80%81%E8%A7%A3%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[归档 所谓的归档，就是将数据写到一个文件里面去。一般我们的应用的变量常量之类的数据都是在内存里面的，只要APP关闭，这些数据都会丢失。但是把数据存储到文件里面去，就能将数据保存到本地磁盘里面（目前iOS基本就是在沙盒里面操作了），不管是APP关闭还是重启设备，下次启动APP的时候都能够读出来。 解档 所谓解档(别人也叫反归档)，就是将数据从文件里面读取出来。在程序里面使用。如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，可以直接用NSKeyedArchiver进行归档和恢复。不是所有的对象都可以直接用这种方法进行归档，只有遵守了NSCoding协议的对象才可以 基本类型数据归档12345678910111213141516// 沙盒ducument目录NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];// 完整的文件路径NSString *path = [docPath stringByAppendingPathComponent:@"名称"];NSString *str = @"测试文字";NSArray *array = @[@"1", @"2", @"3"];NSDictionary *dic = @&#123;@"name":@"张三", @"sex":@"男", @"age":@"22"&#125;;NSError *error;NSData *data = [NSKeyedArchiver archivedDataWithRootObject:dic requiringSecureCoding:true error:&amp;error];if (![data writeToFile:path atomically:YES]) &#123; NSLog(@"Failed to write file to filePath");&#125; else &#123; NSLog(@"Success to write file to filePath");&#125; 解档123NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];NSString *path = [docPath stringByAppendingPathComponent:@"名称"];id obj = [NSKeyedUnarchiver unarchiveObjectWithFile:path]; Model数据首先Model需要遵循，并重新其两个方法1234567891011121314151617181920212223@interface Model : NSObject &lt;NSCoding&gt;@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;@property (nonatomic, assign) BOOL sex;@end- (void)encodeWithCoder:(nonnull NSCoder *)aCoder &#123; [aCoder encodeObject:self.name forKey:@"name"]; [aCoder encodeObject:@(self.age) forKey:@"age"]; [aCoder encodeObject:@(self.sex) forKey:@"sex"];&#125;- (nullable instancetype)initWithCoder:(nonnull NSCoder *)aDecoder &#123; self = [super init]; if (self) &#123; self.name = [aDecoder decodeObjectForKey:@"name"]; self.age = (NSInteger)[aDecoder decodeObjectForKey:@"age"]; self.sex = [aDecoder decodeObjectForKey:@"sex"]; &#125; return self;&#125; 归档123456789101112131415161718// 赋值Model *model = [[Model alloc] init];model.name = @"张三";model.age = 12;model.sex = true;// 沙盒ducument目录NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];NSString *mdoelPath = [docPath stringByAppendingPathComponent:@"名称"];NSError *error;NSData *modelData = [NSKeyedArchiver archivedDataWithRootObject:model requiringSecureCoding:false error:&amp;error];if (![modelData writeToFile:mdoelPath atomically:YES]) &#123; NSLog(@"Failed to write file to filePath");&#125; else &#123; NSLog(@"Success to write file to filePath");&#125; 解档123NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];NSString *path = [docPath stringByAppendingPathComponent:@"名称"];id obj = [NSKeyedUnarchiver unarchiveObjectWithFile:path]; 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** 基本类型归档 @param obj 归档对象 @param fileName 归档文件名称 @param success 成功回调 */- (void)lz_archiverObjectToFile:(id)obj archiverFileName:(NSString *)fileName success:(void(^)(void))success &#123; NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]; NSString *path = [docPath stringByAppendingPathComponent:fileName]; NSError *error; NSData *data = [NSKeyedArchiver archivedDataWithRootObject:obj requiringSecureCoding:true error:&amp;error]; if (![data writeToFile:path atomically:YES]) &#123; NSLog(@"Failed to write file to filePath"); &#125; else &#123; NSLog(@"Success to write file to filePath"); success(); &#125;&#125;/** Model归档 @param obj 归档对象 @param fileName 归档文件名称 @param success 成功回调 */- (void)lz_archiverModelToFile:(NSObject *)obj archiverFileName:(NSString *)fileName success:(void(^)(void))success &#123; NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]; NSString *path = [docPath stringByAppendingPathComponent:fileName]; NSError *error; NSData *data = [NSKeyedArchiver archivedDataWithRootObject:obj requiringSecureCoding:false error:&amp;error]; if (![data writeToFile:path atomically:YES]) &#123; NSLog(@"Failed to write file to filePath"); &#125; else &#123; NSLog(@"Success to write file to filePath"); success(); &#125;&#125;/** 解档 @param fileName 解档文件名称 @param success 成功回调 */- (void)lz_unArchiverFileWithFileName:(NSString *)fileName success:(void(^)(id obj))success &#123; NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]; NSString *path = [docPath stringByAppendingPathComponent:fileName]; id obj = [NSKeyedUnarchiver unarchiveObjectWithFile:path]; success(obj);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS自定义控件：空数据占位图]]></title>
    <url>%2F2018%2F08%2F10%2FiOS%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%9A%E7%A9%BA%E6%95%B0%E6%8D%AE%E5%8D%A0%E4%BD%8D%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[最近由于业务需求，需要封装这样的一个提示页面。看了网上方法感觉都大同小异，其中DZNEmptyDataSet是很好的一个库，但是对我个人而言有点大财小用了。所以就借鉴一下其方法，自己封装一个。感觉有更高的自定义性吧。（我是初学者，请大佬爱护，勿喷）一、封装代码：利用UIScrollView的分类实现1234567891011#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@interface UIScrollView (WD_NoData)// 需要显示的占位页面@property (nonatomic, strong) UIView *noDataView;@endNS_ASSUME_NONNULL_END 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#import "UIScrollView+WD_NoData.h"#import &lt;objc/runtime.h&gt;static char *noDataViewKey = "noDataViewKey";@implementation UIScrollView (WD_NoData)/** 交换方法 @param sel1 原方法 @param sel2 自定义方法 @param cls 类 */void exchangeSelector(SEL sel1, SEL sel2, Class cls) &#123; Class class = [cls class]; Method originalMethod = class_getInstanceMethod(class, sel1); Method swizzledMethod = class_getInstanceMethod(class, sel2); BOOL success = class_addMethod(class, sel1, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (success) &#123; class_replaceMethod(class, sel2, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125;&#125;#pragma mark =============== Setter ===============- (void)setNoDataView:(UIView *)noDataView &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; exchangeSelector(@selector(reloadData), @selector(wd_reloadData), [self class]); &#125;); objc_setAssociatedObject(self, noDataViewKey, noDataView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;#pragma mark =============== Getter ===============- (UIView *)noDataView &#123; UIView *noDataView = objc_getAssociatedObject(self, noDataViewKey); noDataView.frame = self.frame; return noDataView;&#125;- (void)wd_reloadData &#123; [self wd_reloadData]; [self wd_checkData];&#125;#pragma mark =============== 获取数据 ===============- (void)wd_checkData &#123; NSInteger items = 0; if (![self respondsToSelector:@selector(dataSource)]) &#123; return; &#125; // UITableView support if ([self isKindOfClass:[UITableView class]]) &#123; UITableView *tableView = (UITableView *)self; id &lt;UITableViewDataSource&gt; dataSource = tableView.dataSource; NSInteger sections = 1; if (dataSource &amp;&amp; [dataSource respondsToSelector:@selector(numberOfSectionsInTableView:)]) &#123; sections = [dataSource numberOfSectionsInTableView:tableView]; &#125; if (dataSource &amp;&amp; [dataSource respondsToSelector:@selector(tableView:numberOfRowsInSection:)]) &#123; for (NSInteger section = 0; section &lt; sections; section++) &#123; items += [dataSource tableView:tableView numberOfRowsInSection:section]; &#125; &#125; &#125; // UICollectionView support else if ([self isKindOfClass:[UICollectionView class]]) &#123; UICollectionView *collectionView = (UICollectionView *)self; id &lt;UICollectionViewDataSource&gt; dataSource = collectionView.dataSource; NSInteger sections = 1; if (dataSource &amp;&amp; [dataSource respondsToSelector:@selector(numberOfSectionsInCollectionView:)]) &#123; sections = [dataSource numberOfSectionsInCollectionView:collectionView]; &#125; if (dataSource &amp;&amp; [dataSource respondsToSelector:@selector(collectionView:numberOfItemsInSection:)]) &#123; for (NSInteger section = 0; section &lt; sections; section++) &#123; items += [dataSource collectionView:collectionView numberOfItemsInSection:section]; &#125; &#125; &#125; if ( items == 0 ) &#123; [self.superview addSubview:self.noDataView]; &#125; else &#123; [self.noDataView removeFromSuperview]; &#125;&#125;@end 二、使用方法123#import "UIScrollView+WD_NoData.h"// 自定义页面#import "WDTestEmptyView.h" 1234//示例的视图 WDTestEmptyView *view = [NSBundle.mainBundle loadNibNamed:@"WDTestEmptyView" owner:self options:nil].firstObject;// 设置视图self.tableView.noDataView = view; 三、效果图]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据存储：NSUserDefaults]]></title>
    <url>%2F2018%2F08%2F10%2F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%9ANSUserDefault%2F</url>
    <content type="text"><![CDATA[普通类型数据读取12345678910111213141516171819/** 保存基本类型数据 @param obj 保存对象 @param key 键值 */- (void)lz_userDefaultsSetObject:(id)obj keyName:(NSString *)key &#123; [[NSUserDefaults standardUserDefaults] setObject:obj forKey:key];&#125;/** 读取基本类型数据 @param key 键值 @return return value description */- (id)lz_getUserUserDefaultsForKey:(NSString *)key &#123; return [[NSUserDefaults standardUserDefaults] objectForKey:key];&#125; Model对象存储，需要使用规归档配合使用，所有必须是要遵循的对象1234567891011121314151617181920/** Model数据保存 @param obj 保存对象 @param key 键值 */- (void)lz_userDefaultsSetModel:(NSObject *)obj keyName:(NSString *)key &#123; NSData *data = [NSKeyedArchiver archivedDataWithRootObject:obj requiringSecureCoding:false error:nil]; [[NSUserDefaults standardUserDefaults] setObject:data forKey:key];&#125;/** 读取基本类型数据 @param key 键值 @return return value description */- (id)lz_getUserUserDefaultsForKey:(NSString *)key &#123; return [[NSUserDefaults standardUserDefaults] objectForKey:key];&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS开发技巧-不断更新中]]></title>
    <url>%2F2018%2F08%2F06%2FiOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[1、PrefixHeader导入位置写法1$(SRCROOT)/$(PROJECT_NAME)/&lt;#文件所在文件夹名称#&gt;/PrefixHeader.pch 2、隐藏导航栏的两种方式1234567891011121314151617181920212223242526//方式一 《推荐》//在需要隐藏的viewController中遵循&lt;UINavigationControllerDelegate&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; // 设置导航控制器的代理为self self.navigationController.delegate = self;&#125;#pragma mark - UINavigationControllerDelegate// 将要显示控制器- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; // 判断要显示的控制器是否是自己 BOOL isShowHomePage = [viewController isKindOfClass:[self class]]; [self.navigationController setNavigationBarHidden:isShowHomePage animated:YES];&#125;//方式二- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:YES animated:YES];&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [self.navigationController setNavigationBarHidden:NO animated:YES];&#125; 3、TabBarItem要求只显示图片不显示文字12// self 表示需要设置样式的控制器[self.tabBarItem setImageInsets:UIEdgeInsetsMake(6, 0, -6, 0)]; 4、TableView或CollectionView单选1234567891011&lt;!--步骤一、 声明一个全局变量--&gt;@property (nonatomic, assign) NSInteger selectedIndex;&lt;!--步骤二、TableView或CollectionView点击事件的方法中保存点击的index，并刷新--&gt;self.selectedIndex = indexPath.row;[collectionView reloadData];或[tableView reloadData];&lt;!--步骤三、在cellForItemAtIndexPath或cellForRowAtIndexPath方法中判断是否是所保存的index--&gt;if (self.selectedIndex == indexPath.row) &#123; // 设置选中样式&#125; else &#123; // 设置成默认样式 &#125; 5、怎么区分真机还是模拟器1234567#if TARGET_IPHONE_SIMULATOR NSLog(@"run on simulator"); #define SIMULATOR_TEST#else //不定义SIMULATOR_TEST这个宏 NSLog(@"run on device"); #endif 6、if Debug12345#ifdef DEBUG // do sth#else // do sth#endif 7、一键清理所有模拟器安装过的APP12// 先关闭所有模拟器 在终端中输入下面命令即可xcrun simctl erase all 8、SDWebImage清理缓存1234- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; [[[SDWebImageManager sharedManager] imageCache] clearMemory];&#125; 9、UITableView的HeaderView下拉放大123456789101112131、View1:作为显示View2、View2:作为tableView的tableHeaderView，并添加View1，View2的大小和View1大小相同.3、在UIScrollViewDelegate方法中进行设计- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; CGFloat width = UIScreen.mainScreen.bounds.size.width; CGFloat viewHeight = kScreenWidth * 0.5; // View1的初始高度 CGFloat yOffset = scrollView.contentOffset.y; if (yOffset &lt; 0) &#123; CGFloat totalOffset = viewHeight + ABS(yOffset); CGFloat f = totalOffset / viewHeight; self.headerView.frame = CGRectMake(- (width * f - width) / 2, yOffset, width * f, totalOffset); &#125;&#125; 10、Masonry制作就宫格123456789101112131415161718192021222324252627282930313233343536373839404142434445//Objective-C ----&gt; Masonry/**多视图布局@param viewArray 视图数组@param column 列数@param tbSpeace 视图上下间距@param lrSpeace 视图左右间距@param topSpeace 和父视图上间距@param lrSuperViewSpeace 父视图左右间距@param superView 父视图@param viewHeight 视图高度*/- (void)wd_masLayoutSubViewsWithViewArray:(NSArray&lt;UIView *&gt; *)viewArray columnOfRow:(NSInteger)column topBottomOfItemSpeace:(CGFloat)tbSpeace leftRightItemSpeace:(CGFloat)lrSpeace topOfSuperViewSpeace:(CGFloat)topSpeace leftRightSuperViewSpeace:(CGFloat)lrSuperViewSpeace addToSubperView:(UIView *)superView viewHeight:(CGFloat)viewHeight&#123; CGFloat viewWidth = superView.bounds.size.width; CGFloat itemWidth = (viewWidth - lrSuperViewSpeace * 2 - (column - 1) * lrSpeace) / column * 1.0f; CGFloat itemHeight = viewHeight; UIView *last = nil; for (int i = 0; i &lt; viewArray.count; i++) &#123; UIView *item = viewArray[i]; [superView addSubview:item]; [item mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.width.mas_equalTo(itemWidth); make.height.mas_equalTo(itemHeight); CGFloat top = topSpeace + (i / column) * (itemHeight + tbSpeace); make.top.mas_offset(top); if (!last || (i % column) == 0) &#123; make.left.mas_offset(lrSuperViewSpeace); &#125;else&#123; make.left.mas_equalTo(last.mas_right).mas_offset(lrSpeace); &#125; &#125;]; last = item; &#125;&#125; 11、Snapkit制作九宫格12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Swift ----&gt; SnapKit/// 多视图布局////// - Parameters:/// - viewArray: 视图数组/// - columnOfRow: 列数/// - topBottomOfItemSpeace: 视图上下间距/// - leftRightItemSpeace: 视图左右间距/// - topOfSuperViewSpeace: 和父视图上间距/// - leftRightSuperViewSpeace: 父视图左右间距/// - addToSubperView: 父视图/// - viewHeight: 视图高度func wd_masLayoutSubViews(viewArray:Array&lt;UIView&gt;, columnOfRow:Int, topBottomOfItemSpeace:CGFloat, leftRightItemSpeace:CGFloat, topOfSuperViewSpeace:CGFloat, leftRightSuperViewSpeace:CGFloat, addToSubperView:UIView, viewHeight:CGFloat) -&gt; Void &#123; let viewWidth = addToSubperView.bounds.width let tempW = leftRightSuperViewSpeace * 2 + CGFloat(columnOfRow - 1) * leftRightItemSpeace let itemWidth = (viewWidth - tempW) / CGFloat(columnOfRow) let itemHeight = viewHeight var lastView:UIView? for (index) in viewArray.enumerated() &#123; let item = viewArray[i] addToSubperView.addSubview(item) item.snp.makeConstraints &#123; (make) in make.width.equalTo(itemWidth) make.height.equalTo(itemHeight) let top = topOfSuperViewSpeace + CGFloat(i / columnOfRow) * (itemHeight + topBottomOfItemSpeace) make.top.equalTo(top) if !(lastView != nil) || i%columnOfRow == 0 &#123; make.left.equalTo(leftRightSuperViewSpeace) &#125; else &#123; make.left.equalTo((lastView?.snp.right)!).offset(leftRightItemSpeace) &#125; lastView = item &#125; &#125;&#125; 13、通过身份证计算年龄1234567891011121314151617181920212223242526272829303132333435363738/** 通过身份证计算年龄 */- (NSString *)calculationAgeWithBirthday: (NSString *)birthday &#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSDate *nowDate = [NSDate date]; NSString *birth = birthday; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc]init]; [dateFormatter setDateFormat:@"yyyy-MM-dd"]; NSDate *birthDay = [dateFormatter dateFromString:birth]; unsigned int unitFlags = NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay; NSDateComponents *date = [calendar components:unitFlags fromDate:birthDay toDate:nowDate options:0]; if ([date year] &gt; 0) &#123; return [NSString stringWithFormat:@"%ld岁", (long)[date year]]; &#125; else if([date month] &gt; 0) &#123; return [NSString stringWithFormat:@"%ld月", (long)[date month]]; &#125; else if([date day] &gt; 0)&#123; return [NSString stringWithFormat:@"%ld天", (long)[date day]]; &#125; else &#123; return @"0天"; &#125;&#125;- (NSString *)ageStrFromIdentityCard:(NSString *)numberStr &#123; NSString *dateSt; NSMutableString *dateS; if (numberStr.length &gt; 15) &#123; dateSt = [numberStr substringWithRange:NSMakeRange(6, 8)]; dateS = [NSMutableString stringWithFormat:@"%@", dateSt]; [dateS insertString:@"-" atIndex:4]; [dateS insertString:@"-" atIndex:7]; &#125; else &#123; // 只考虑 19开头的15位的身份证号 dateSt = [NSString stringWithFormat:@"19%@",[numberStr substringWithRange:NSMakeRange(6, 6)]]; dateS = [NSMutableString stringWithFormat:@"%@", dateSt]; [dateS insertString:@"-" atIndex:4]; [dateS insertString:@"-" atIndex:7]; &#125; return [self calculationAgeWithBirthday:dateS];&#125; 14、利用runtime自动归档123456789101112131415161718192021222324252627// 导入头文件#import &lt;objc/runtime.h&gt;// 遵循协议&lt;NSCoding&gt;// 实现方法- (id)initWithCoder:(NSCoder *)aDecoder &#123; if (self = [super init]) &#123; unsigned int outCount; Ivar * ivars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar ivar = ivars[i]; NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)]; [self setValue:[aDecoder decodeObjectForKey:key] forKey:key]; &#125; &#125; return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder &#123; unsigned int outCount; Ivar * ivars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar ivar = ivars[i]; NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)]; [aCoder encodeObject:[self valueForKey:key] forKey:key]; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据存储：plist]]></title>
    <url>%2F2018%2F08%2F05%2F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%9Aplist%2F</url>
    <content type="text"><![CDATA[沙盒存储中四个文件夹 Document:Documents中一般保存应用程序本身产生文件数据，例如游戏进度，绘图软件的绘图等， iTunes备份和恢复的时候，会包括此目录， 注意：在此目录下不要保存从网络上下载的文件，否则app无法上架！ Library:目录下有两个子目录：Caches 和 Preferences Caches:此目录用来保存应用程序运行时生成的需要持久化的数据，这些数据一般存储体积比较大，又不是十分重要，比如网络请求数据等。这些数据需要用户负责删除。iTunes同步设备时不会备份该目录 Preferences：此目录保存应用程序的所有偏好设置，iOS的Settings(设置)应用会在该目录中查找应用的设置信息。iTunes同步设备时会备份该目录在Preferences/下不能直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好 SystemData:存放系统数据。 tmp:此目录保存应用程序运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录 添加/修改数据:根据Key值 12[dd setObject:@"我添加的新内容" forKey:@"content"];[dataDic writeToFile:filePatch atomically:YES]; 移除数据:根据Key值 1[dataDic removeObjectForKey:@"age"]; 读取数据 读取项目中Plist文件 12345// 获取文件路径NSString *path = [[NSBundle mainBundle] pathForResource:@"DataInfo" ofType:@"plist"];// 类型自己选取NSDictionary *dic = [NSDictionary dictionaryWithContentsOfFile:path];NSArray *array = [NSArray arrayWithContentsOfFile:path]; 读取,或生成沙盒中Plist文件 1234567// 获取路径对象NSArray *pathArray = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *patPath = [pathArray objectAtIndex:0];// 根据 生成的Plist的名称获取最后路径NSString *filePatch = [patPath stringByAppendingPathComponent:@"test.plist"];NSDictionary *fileDic = [NSDictionary dictionaryWithContentsOfFile:filePatch];NSArray *fileArray = [NSArray arrayWithContentsOfFile:filePatch]; 添加数据1234567891011121314// 获取路径对象NSArray *pathArray = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *path = [pathArray objectAtIndex:0];// 获取文件的完整路径NSString *filePatch = [path stringByAppendingPathComponent:@"test.plist"]; // 写入数据到plist文件NSMutableDictionary *dic1 = [NSMutableDictionary dictionaryWithObjectsAndKeys:@"小小虎",@"name", @"5",@"age", @"boy",@"sex", nil];NSMutableDictionary *dic2 = [NSMutableDictionary dictionaryWithObjectsAndKeys:@"小小兮",@"name", @"6",@"age", @"girl",@"sex", nil];// 将上面2个小字典保存到大字典里面NSMutableDictionary *dataDic = [NSMutableDictionary dictionary];[dataDic setObject:dic1 forKey:@"一年级"];[dataDic setObject:dic2 forKey:@"二年级"]; // 写入plist里面[dataDic writeToFile:filePatch atomically:YES]; //读取plist文件的内容 修改数据12345678910111213141516// 获取plist文件的路径NSArray *pathArray = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *path1 = [pathArray objectAtIndex:0];NSString *myPath = [path1 stringByAppendingPathComponent:@"test.plist"]; NSMutableDictionary *dataDictionary = [[NSMutableDictionary alloc] initWithContentsOfFile:myPath]; // 修改字典里面的内容,先按照结构取到你想修改内容的小字典NSMutableDictionary *dd = [dataDictionary objectForKey:@"一年级"];[dd setObject:@"我改名字了哦" forKey:@"name"];[dd setObject:@"我添加的新内容" forKey:@"content"];[dd removeObjectForKey:@"age"]; //修改成功以后，将这个小字典重新添加到大字典里面[dataDictionary setObject:dd forKey:@"一年级"];[dataDictionary writeToFile:myPath atomically:YES]; 删除Plist文件12345678NSFileManager *fileMger = [NSFileManager defaultManager];NSString *xiaoXiPath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)objectAtIndex:0] stringByAppendingPathComponent:@"test.plist"];// 如果文件路径存在的话BOOL bRet = [fileMger fileExistsAtPath:xiaoXiPath];if (bRet) &#123; NSError *err; [fileMger removeItemAtPath:xiaoXiPath error:&amp;err];&#125;]]></content>
  </entry>
</search>
